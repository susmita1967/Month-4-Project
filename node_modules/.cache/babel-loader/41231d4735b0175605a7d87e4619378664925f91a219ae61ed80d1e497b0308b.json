{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = require(\"./../utils\");\nconst Helpers = require(\"./helpers\");\nconst _ = require(\"lodash\");\nconst Association = require(\"./base\");\nconst BelongsTo = require(\"./belongs-to\");\nconst HasMany = require(\"./has-many\");\nconst HasOne = require(\"./has-one\");\nconst AssociationError = require(\"../errors\").AssociationError;\nconst EmptyResultError = require(\"../errors\").EmptyResultError;\nconst Op = require(\"../operators\");\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    if (this.options.through === void 0 || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(\"\".concat(source.name, \".belongsToMany(\").concat(target.name, \") requires through option, pass either a string or a model\"));\n    }\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n    this.associationType = \"BelongsToMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = __spreadValues({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError(\"'as' must be defined for many-to-many self-associations\");\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    _.each(this.target.associations, association => {\n      if (association.associationType !== \"BelongsToMany\") return;\n      if (association.target !== this.source) return;\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n    this._createForeignAndOtherKeys();\n    if (typeof this.through.model === \"string\") {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [],\n          paranoid: this.through.paranoid ? this.through.paranoid : false,\n          validate: {}\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n    Object.assign(this.options, _.pick(this.through.model.options, [\"timestamps\", \"createdAt\", \"updatedAt\", \"deletedAt\", \"paranoid\"]));\n    if (this.paired) {\n      let needInjectPaired = false;\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n    this.associationAccessor = this.as;\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: \"get\".concat(plural),\n      set: \"set\".concat(plural),\n      addMultiple: \"add\".concat(plural),\n      add: \"add\".concat(singular),\n      create: \"create\".concat(singular),\n      remove: \"remove\".concat(singular),\n      removeMultiple: \"remove\".concat(plural),\n      hasSingle: \"has\".concat(singular),\n      hasAll: \"has\".concat(plural),\n      count: \"count\".concat(plural)\n    };\n  }\n  _createForeignAndOtherKeys() {\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize([this.source.options.name.singular, this.sourceKey].join(\"_\"));\n    }\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize([this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular, this.targetKey].join(\"_\"));\n    }\n  }\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if ([this.foreignKey, this.otherKey].includes(attributeName)) {\n          attribute.primaryKey = false;\n        } else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = __spreadValues({\n      type: sourceKeyType\n    }, this.foreignKeyAttribute);\n    const targetAttribute = __spreadValues({\n      type: targetKeyType\n    }, this.otherKeyAttribute);\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === \"string\" && this.options.uniqueKey !== \"\") {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, \"unique\"].join(\"_\");\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = \"CASCADE\";\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = \"CASCADE\";\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = \"CASCADE\";\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = \"CASCADE\";\n    }\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n    this.through.model.refreshAttributes();\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n    if (this.options.sequelize.options.dialect === \"db2\" && this.source.rawAttributes[this.sourceKey].primaryKey !== true) {\n      this.source.rawAttributes[this.sourceKey].unique = true;\n    }\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n    if (this.scope) {\n      scopeWhere = __spreadValues({}, this.scope);\n    }\n    options.where = {\n      [Op.and]: [scopeWhere, options.where]\n    };\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, \"paranoid\", true),\n        where: throughWhere\n      });\n    }\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n    return model.findAll(options);\n  }\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [[sequelize.fn(\"COUNT\", sequelize.col([this.target.name, this.targetKeyField].join(\".\"))), \"count\"]];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n    options = __spreadProps(__spreadValues({\n      raw: true\n    }, options), {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [{\n        [Op.or]: instancePrimaryKeys\n      }, options.where]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return _.differenceWith(instancePrimaryKeys, associatedObjects, (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey)\n    }, this.through.scope);\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n      const unassociatedObjects = newAssociatedObjects.filter(obj => !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey)));\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).length) {\n            promises.push(this.through.model.update(attributes, Object.assign(options, {\n              where: {\n                [identifier]: sourceInstance.get(sourceKey),\n                [foreignIdentifier]: newObj.get(targetKey)\n              }\n            })));\n          }\n        }\n      }\n      if (obsoleteAssociations.length > 0) {\n        promises.push(this.through.model.destroy(__spreadProps(__spreadValues({}, options), {\n          where: __spreadValues({\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier])\n          }, this.through.scope)\n        })));\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, defaultAttributes), unassociatedObject[this.through.model.name]), {\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey)\n          }), this.through.scope);\n        });\n        promises.push(this.through.model.bulkCreate(bulk, __spreadValues({\n          validate: true\n        }, options)));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await this.through.model.findAll(__spreadProps(__spreadValues({}, options), {\n        where,\n        raw: true\n      }));\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations([]);\n      throw error;\n    }\n  }\n  async add(sourceInstance, newInstances, options) {\n    if (!newInstances) return Promise.resolve();\n    options = __spreadValues({}, options);\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n    newInstances = association.toInstanceArray(newInstances);\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey))\n    }, association.through.scope);\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          Object.assign(attributes, association.through.scope);\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, __spreadValues({\n          validate: true\n        }, options)));\n      }\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n        promises.push(association.through.model.update(attributes, Object.assign(options, {\n          where: {\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: assoc.get(targetKey)\n          }\n        })));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await association.through.model.findAll(__spreadProps(__spreadValues({}, options), {\n        where,\n        raw: true\n      }));\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations();\n      throw error;\n    }\n  }\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n    options = options || {};\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n    return association.through.model.destroy(__spreadProps(__spreadValues({}, options), {\n      where\n    }));\n  }\n  async create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n    values = values || {};\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n    const newAssociatedObject = await association.target.create(values, options);\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, [\"fields\"]));\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;","map":{"version":3,"names":["Utils","require","Helpers","_","Association","BelongsTo","HasMany","HasOne","AssociationError","EmptyResultError","Op","BelongsToMany","constructor","source","target","options","through","concat","name","model","associationType","targetAssociation","sequelize","__spreadValues","isMultiAssociation","doubleLinked","as","isSelfAssociation","isAliased","isPlainObject","plural","singular","singularize","combinedTableName","combineTableNames","tableName","each","associations","association","paired","sourceKey","primaryKeyAttribute","sourceKeyField","rawAttributes","field","targetKey","targetKeyField","targetKeyDefault","_createForeignAndOtherKeys","isDefined","define","Object","assign","indexes","paranoid","validate","pick","needInjectPaired","otherKey","otherKeyDefault","foreignKey","_injectAttributes","throughModel","combinedName","associationAccessor","upperFirst","accessors","get","set","addMultiple","add","create","remove","removeMultiple","hasSingle","hasAll","count","isObject","foreignKeyAttribute","fieldName","camelize","join","otherKeyAttribute","identifier","foreignIdentifier","attribute","attributeName","primaryKey","_autoGenerated","includes","primaryKeyDeleted","sourceKeyType","type","targetKeyType","sourceAttribute","targetAttribute","unique","uniqueKey","constraints","references","getTableName","key","onDelete","onUpdate","refreshAttributes","identifierField","foreignIdentifierField","dialect","toSource","manyFromSource","oneFromSource","toTarget","manyFromTarget","oneFromTarget","checkNamingCollision","mixin","obj","methods","aliases","mixinMethods","instance","cloneDeep","scopeWhere","throughWhere","scope","where","and","include","push","attributes","joinTableAttributes","required","prototype","hasOwnProperty","call","unscoped","schema","schemaDelimiter","findAll","fn","col","raw","plain","result","parseInt","has","sourceInstance","instances","Array","isArray","__spreadProps","instancePrimaryKeys","map","or","associatedObjects","differenceWith","a","b","isEqual","length","newAssociatedObjects","toInstanceArray","updateAssociations","currentRows","obsoleteAssociations","promises","defaultAttributes","unassociatedObjects","filter","some","currentRow","newObj","find","throughAttributes","keys","update","destroy","obsoleteAssociation","bulk","unassociatedObject","bulkCreate","Promise","all","error","newInstances","resolve","newInstance","changedAssociations","existingAssociation","current","assoc","oldAssociatedObjects","values","fields","newAssociatedObject","omit","verifyAssociationAlias","alias","module","exports","default"],"sources":["E:\\Sankey_Project\\node_modules\\sequelize\\src\\associations\\belongs-to-many.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\nconst EmptyResultError = require('../errors').EmptyResultError;\nconst Op = require('../operators');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * const project = await Project.create({ id: 11 });\n * await user.addProjects([project, 12]);\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * const projects = await user.getProjects();\n * const p1 = projects[0];\n * p1.UserProjects.started // Is this project started yet?\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = { ...this.options.through };\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    /*\n    * Default/generated source/target keys\n    */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n\n    this._createForeignAndOtherKeys();\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: this.through.paranoid ? this.through.paranoid : false, // Default to non-paranoid join (referenced in #11991)\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      let needInjectPaired = false;\n\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.sourceKey\n        ].join('_')\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize(\n        [\n          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n          this.targetKey\n        ].join('_')\n      );\n    }\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if ([this.foreignKey, this.otherKey].includes(attributeName)) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = { type: sourceKeyType, ...this.foreignKeyAttribute };\n    const targetAttribute = { type: targetKeyType, ...this.otherKeyAttribute };\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.through.model.refreshAttributes();\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    // For Db2 server, a reference column of a FOREIGN KEY must be unique\n    // else, server throws SQL0573N error. Hence, setting it here explicitly\n    // for non primary columns.\n    if (this.options.sequelize.options.dialect === 'db2' &&\n        this.source.rawAttributes[this.sourceKey].primaryKey !== true) {\n      this.source.rawAttributes[this.sourceKey].unique = true;\n    }\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @see\n   * {@link Model} for a full explanation of options\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   * @param {object} [options.through.where] An optional where clause applied to through model (join table)\n   * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (this.scope) {\n      scopeWhere = { ...this.scope };\n    }\n\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, 'paranoid', true),\n        where: throughWhere\n      });\n    }\n\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    const result = await this.get(instance, options);\n\n    return parseInt(result.count, 10);\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model} sourceInstance source instance to check for an association with\n   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n   * @param {object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise<boolean>}\n   */\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = {\n      raw: true,\n      ...options,\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    };\n\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n\n    const associatedObjects = await this.get(sourceInstance, options);\n\n    return _.differenceWith(instancePrimaryKeys, associatedObjects,\n      (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys.\n   * Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {object} [options.validate] Run validation for the join model\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      ...this.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).length) {\n            promises.push(\n              this.through.model.update(attributes, Object.assign(options, {\n                where: {\n                  [identifier]: sourceInstance.get(sourceKey),\n                  [foreignIdentifier]: newObj.get(targetKey)\n                }\n              }\n              ))\n            );\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        promises.push(\n          this.through.model.destroy({\n            ...options,\n            where: {\n              [identifier]: sourceInstance.get(sourceKey),\n              [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]),\n              ...this.through.scope\n            }\n          })\n        );\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          return {\n            ...defaultAttributes,\n            ...unassociatedObject[this.through.model.name],\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey),\n            ...this.through.scope\n          };\n        });\n\n        promises.push(this.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await this.through.model.findAll({ ...options, where, raw: true });\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations([]);\n      throw error;\n    }\n  }\n\n  /**\n   * Associate one or several rows with source instance. It will not un-associate any already associated instance\n   * that may be missing from `newInstances`.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {object} [options.validate] Run validation for the join model.\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Promise.resolve();\n\n    options = { ...options };\n\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey)),\n      ...association.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = { ...defaultAttributes, ...throughAttributes };\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        } })));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await association.through.model.findAll({ ...options, where, raw: true });\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations();\n      throw error;\n    }\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {object} [options] Options passed to `through.destroy`\n   *\n   * @returns {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n\n    return association.through.model.destroy({ ...options, where });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {object} [values] values for target model\n   * @param {object} [options] Options passed to create and add\n   * @param {object} [options.through] Additional attributes for the join table\n   *\n   * @returns {Promise}\n   */\n  async create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    const newAssociatedObject = await association.target.create(values, options);\n\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));\n    return newAssociatedObject;\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA,MAAMA,KAAA,GAAQC,OAAA,CAAQ;AACtB,MAAMC,OAAA,GAAUD,OAAA,CAAQ;AACxB,MAAME,CAAA,GAAIF,OAAA,CAAQ;AAClB,MAAMG,WAAA,GAAcH,OAAA,CAAQ;AAC5B,MAAMI,SAAA,GAAYJ,OAAA,CAAQ;AAC1B,MAAMK,OAAA,GAAUL,OAAA,CAAQ;AACxB,MAAMM,MAAA,GAASN,OAAA,CAAQ;AACvB,MAAMO,gBAAA,GAAmBP,OAAA,CAAQ,aAAaO,gBAAA;AAC9C,MAAMC,gBAAA,GAAmBR,OAAA,CAAQ,aAAaQ,gBAAA;AAC9C,MAAMC,EAAA,GAAKT,OAAA,CAAQ;AA6CnB,MAAAU,aAAA,SAA4BP,WAAA,CAAY;EACtCQ,YAAYC,MAAA,EAAQC,MAAA,EAAQC,OAAA,EAAS;IACnC,MAAMF,MAAA,EAAQC,MAAA,EAAQC,OAAA;IAEtB,IAAI,KAAKA,OAAA,CAAQC,OAAA,KAAY,UAAa,KAAKD,OAAA,CAAQC,OAAA,KAAY,QAAQ,KAAKD,OAAA,CAAQC,OAAA,KAAY,MAAM;MACxG,MAAM,IAAIR,gBAAA,IAAAS,MAAA,CAAoBJ,MAAA,CAAOK,IAAA,qBAAAD,MAAA,CAAsBH,MAAA,CAAOI,IAAA;IAAA;IAGpE,IAAI,CAAC,KAAKH,OAAA,CAAQC,OAAA,CAAQG,KAAA,EAAO;MAC/B,KAAKJ,OAAA,CAAQC,OAAA,GAAU;QACrBG,KAAA,EAAOJ,OAAA,CAAQC;MAAA;IAAA;IAInB,KAAKI,eAAA,GAAkB;IACvB,KAAKC,iBAAA,GAAoB;IACzB,KAAKC,SAAA,GAAYT,MAAA,CAAOS,SAAA;IACxB,KAAKN,OAAA,GAAUO,cAAA,KAAK,KAAKR,OAAA,CAAQC,OAAA;IACjC,KAAKQ,kBAAA,GAAqB;IAC1B,KAAKC,YAAA,GAAe;IAEpB,IAAI,CAAC,KAAKC,EAAA,IAAM,KAAKC,iBAAA,EAAmB;MACtC,MAAM,IAAInB,gBAAA,CAAiB;IAAA;IAG7B,IAAI,KAAKkB,EAAA,EAAI;MACX,KAAKE,SAAA,GAAY;MAEjB,IAAIzB,CAAA,CAAE0B,aAAA,CAAc,KAAKH,EAAA,GAAK;QAC5B,KAAKX,OAAA,CAAQG,IAAA,GAAO,KAAKQ,EAAA;QACzB,KAAKA,EAAA,GAAK,KAAKA,EAAA,CAAGI,MAAA;MAAA,OACb;QACL,KAAKf,OAAA,CAAQG,IAAA,GAAO;UAClBY,MAAA,EAAQ,KAAKJ,EAAA;UACbK,QAAA,EAAU/B,KAAA,CAAMgC,WAAA,CAAY,KAAKN,EAAA;QAAA;MAAA;IAAA,OAGhC;MACL,KAAKA,EAAA,GAAK,KAAKZ,MAAA,CAAOC,OAAA,CAAQG,IAAA,CAAKY,MAAA;MACnC,KAAKf,OAAA,CAAQG,IAAA,GAAO,KAAKJ,MAAA,CAAOC,OAAA,CAAQG,IAAA;IAAA;IAG1C,KAAKe,iBAAA,GAAoBjC,KAAA,CAAMkC,iBAAA,CAC7B,KAAKrB,MAAA,CAAOsB,SAAA,EACZ,KAAKR,iBAAA,GAAoB,KAAKD,EAAA,IAAM,KAAKZ,MAAA,CAAOqB,SAAA,GAAY,KAAKrB,MAAA,CAAOqB,SAAA;IAM1E,IAAI,KAAKR,iBAAA,EAAmB;MAC1B,KAAKN,iBAAA,GAAoB;IAAA;IAM3BlB,CAAA,CAAEiC,IAAA,CAAK,KAAKtB,MAAA,CAAOuB,YAAA,EAAcC,WAAA,IAAe;MAC9C,IAAIA,WAAA,CAAYlB,eAAA,KAAoB,iBAAiB;MACrD,IAAIkB,WAAA,CAAYxB,MAAA,KAAW,KAAKD,MAAA,EAAQ;MAExC,IAAI,KAAKE,OAAA,CAAQC,OAAA,CAAQG,KAAA,KAAUmB,WAAA,CAAYvB,OAAA,CAAQC,OAAA,CAAQG,KAAA,EAAO;QACpE,KAAKoB,MAAA,GAASD,WAAA;QACdA,WAAA,CAAYC,MAAA,GAAS;MAAA;IAAA;IAOzB,KAAKC,SAAA,GAAY,KAAKzB,OAAA,CAAQyB,SAAA,IAAa,KAAK3B,MAAA,CAAO4B,mBAAA;IACvD,KAAKC,cAAA,GAAiB,KAAK7B,MAAA,CAAO8B,aAAA,CAAc,KAAKH,SAAA,EAAWI,KAAA,IAAS,KAAKJ,SAAA;IAE9E,IAAI,KAAKzB,OAAA,CAAQ8B,SAAA,EAAW;MAC1B,KAAKA,SAAA,GAAY,KAAK9B,OAAA,CAAQ8B,SAAA;MAC9B,KAAKC,cAAA,GAAiB,KAAKhC,MAAA,CAAO6B,aAAA,CAAc,KAAKE,SAAA,EAAWD,KAAA,IAAS,KAAKC,SAAA;IAAA,OACzE;MACL,KAAKE,gBAAA,GAAmB;MACxB,KAAKF,SAAA,GAAY,KAAK/B,MAAA,CAAO2B,mBAAA;MAC7B,KAAKK,cAAA,GAAiB,KAAKhC,MAAA,CAAO6B,aAAA,CAAc,KAAKE,SAAA,EAAWD,KAAA,IAAS,KAAKC,SAAA;IAAA;IAGhF,KAAKG,0BAAA;IAEL,IAAI,OAAO,KAAKhC,OAAA,CAAQG,KAAA,KAAU,UAAU;MAC1C,IAAI,CAAC,KAAKG,SAAA,CAAU2B,SAAA,CAAU,KAAKjC,OAAA,CAAQG,KAAA,GAAQ;QACjD,KAAKH,OAAA,CAAQG,KAAA,GAAQ,KAAKG,SAAA,CAAU4B,MAAA,CAAO,KAAKlC,OAAA,CAAQG,KAAA,EAAO,IAAIgC,MAAA,CAAOC,MAAA,CAAO,KAAKrC,OAAA,EAAS;UAC7FoB,SAAA,EAAW,KAAKnB,OAAA,CAAQG,KAAA;UACxBkC,OAAA,EAAS;UACTC,QAAA,EAAU,KAAKtC,OAAA,CAAQsC,QAAA,GAAW,KAAKtC,OAAA,CAAQsC,QAAA,GAAW;UAC1DC,QAAA,EAAU;QAAA;MAAA,OAEP;QACL,KAAKvC,OAAA,CAAQG,KAAA,GAAQ,KAAKG,SAAA,CAAUH,KAAA,CAAM,KAAKH,OAAA,CAAQG,KAAA;MAAA;IAAA;IAI3DgC,MAAA,CAAOC,MAAA,CAAO,KAAKrC,OAAA,EAASZ,CAAA,CAAEqD,IAAA,CAAK,KAAKxC,OAAA,CAAQG,KAAA,CAAMJ,OAAA,EAAS,CAC7D,cAAc,aAAa,aAAa,aAAa;IAGvD,IAAI,KAAKwB,MAAA,EAAQ;MACf,IAAIkB,gBAAA,GAAmB;MAEvB,IAAI,KAAKV,gBAAA,EAAkB;QACzB,KAAKF,SAAA,GAAY,KAAKN,MAAA,CAAOC,SAAA;QAC7B,KAAKM,cAAA,GAAiB,KAAKP,MAAA,CAAOG,cAAA;QAClC,KAAKM,0BAAA;MAAA;MAEP,IAAI,KAAKT,MAAA,CAAOQ,gBAAA,EAAkB;QAGhC,IAAI,KAAKR,MAAA,CAAOM,SAAA,KAAc,KAAKL,SAAA,EAAW;UAC5C,OAAO,KAAKxB,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKJ,MAAA,CAAOmB,QAAA;UACpD,KAAKnB,MAAA,CAAOM,SAAA,GAAY,KAAKL,SAAA;UAC7B,KAAKD,MAAA,CAAOO,cAAA,GAAiB,KAAKJ,cAAA;UAClC,KAAKH,MAAA,CAAOS,0BAAA;UACZS,gBAAA,GAAmB;QAAA;MAAA;MAIvB,IAAI,KAAKE,eAAA,EAAiB;QACxB,KAAKD,QAAA,GAAW,KAAKnB,MAAA,CAAOqB,UAAA;MAAA;MAE9B,IAAI,KAAKrB,MAAA,CAAOoB,eAAA,EAAiB;QAG/B,IAAI,KAAKpB,MAAA,CAAOmB,QAAA,KAAa,KAAKE,UAAA,EAAY;UAC5C,OAAO,KAAK5C,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKJ,MAAA,CAAOmB,QAAA;UACpD,KAAKnB,MAAA,CAAOmB,QAAA,GAAW,KAAKE,UAAA;UAC5BH,gBAAA,GAAmB;QAAA;MAAA;MAIvB,IAAIA,gBAAA,EAAkB;QACpB,KAAKlB,MAAA,CAAOsB,iBAAA;MAAA;IAAA;IAIhB,IAAI,KAAK7C,OAAA,EAAS;MAChB,KAAK8C,YAAA,GAAe,KAAK9C,OAAA,CAAQG,KAAA;IAAA;IAGnC,KAAKJ,OAAA,CAAQoB,SAAA,GAAY,KAAK4B,YAAA,GAAe,KAAK/C,OAAA,CAAQG,KAAA,KAAUgC,MAAA,CAAO,KAAKnC,OAAA,CAAQG,KAAA,IAAS,KAAKH,OAAA,CAAQG,KAAA,CAAMgB,SAAA,GAAY,KAAKnB,OAAA,CAAQG,KAAA;IAE7I,KAAK6C,mBAAA,GAAsB,KAAKtC,EAAA;IAGhC,MAAMI,MAAA,GAAS3B,CAAA,CAAE8D,UAAA,CAAW,KAAKlD,OAAA,CAAQG,IAAA,CAAKY,MAAA;IAC9C,MAAMC,QAAA,GAAW5B,CAAA,CAAE8D,UAAA,CAAW,KAAKlD,OAAA,CAAQG,IAAA,CAAKa,QAAA;IAEhD,KAAKmC,SAAA,GAAY;MACfC,GAAA,QAAAlD,MAAA,CAAWa,MAAA;MACXsC,GAAA,QAAAnD,MAAA,CAAWa,MAAA;MACXuC,WAAA,QAAApD,MAAA,CAAmBa,MAAA;MACnBwC,GAAA,QAAArD,MAAA,CAAWc,QAAA;MACXwC,MAAA,WAAAtD,MAAA,CAAiBc,QAAA;MACjByC,MAAA,WAAAvD,MAAA,CAAiBc,QAAA;MACjB0C,cAAA,WAAAxD,MAAA,CAAyBa,MAAA;MACzB4C,SAAA,QAAAzD,MAAA,CAAiBc,QAAA;MACjB4C,MAAA,QAAA1D,MAAA,CAAca,MAAA;MACd8C,KAAA,UAAA3D,MAAA,CAAea,MAAA;IAAA;EAAA;EAInBkB,2BAAA,EAA6B;IAI3B,IAAI7C,CAAA,CAAE0E,QAAA,CAAS,KAAK9D,OAAA,CAAQ6C,UAAA,GAAa;MACvC,KAAKkB,mBAAA,GAAsB,KAAK/D,OAAA,CAAQ6C,UAAA;MACxC,KAAKA,UAAA,GAAa,KAAKkB,mBAAA,CAAoB5D,IAAA,IAAQ,KAAK4D,mBAAA,CAAoBC,SAAA;IAAA,OACvE;MACL,KAAKD,mBAAA,GAAsB;MAC3B,KAAKlB,UAAA,GAAa,KAAK7C,OAAA,CAAQ6C,UAAA,IAAc5D,KAAA,CAAMgF,QAAA,CACjD,CACE,KAAKnE,MAAA,CAAOE,OAAA,CAAQG,IAAA,CAAKa,QAAA,EACzB,KAAKS,SAAA,EACLyC,IAAA,CAAK;IAAA;IAIX,IAAI9E,CAAA,CAAE0E,QAAA,CAAS,KAAK9D,OAAA,CAAQ2C,QAAA,GAAW;MACrC,KAAKwB,iBAAA,GAAoB,KAAKnE,OAAA,CAAQ2C,QAAA;MACtC,KAAKA,QAAA,GAAW,KAAKwB,iBAAA,CAAkBhE,IAAA,IAAQ,KAAKgE,iBAAA,CAAkBH,SAAA;IAAA,OACjE;MACL,IAAI,CAAC,KAAKhE,OAAA,CAAQ2C,QAAA,EAAU;QAC1B,KAAKC,eAAA,GAAkB;MAAA;MAGzB,KAAKuB,iBAAA,GAAoB;MACzB,KAAKxB,QAAA,GAAW,KAAK3C,OAAA,CAAQ2C,QAAA,IAAY1D,KAAA,CAAMgF,QAAA,CAC7C,CACE,KAAKrD,iBAAA,GAAoB3B,KAAA,CAAMgC,WAAA,CAAY,KAAKN,EAAA,IAAM,KAAKZ,MAAA,CAAOC,OAAA,CAAQG,IAAA,CAAKa,QAAA,EAC/E,KAAKc,SAAA,EACLoC,IAAA,CAAK;IAAA;EAAA;EAObpB,kBAAA,EAAoB;IAClB,KAAKsB,UAAA,GAAa,KAAKvB,UAAA;IACvB,KAAKwB,iBAAA,GAAoB,KAAK1B,QAAA;IAI9BvD,CAAA,CAAEiC,IAAA,CAAK,KAAKpB,OAAA,CAAQG,KAAA,CAAMwB,aAAA,EAAe,CAAC0C,SAAA,EAAWC,aAAA,KAAkB;MACrE,IAAID,SAAA,CAAUE,UAAA,KAAe,QAAQF,SAAA,CAAUG,cAAA,KAAmB,MAAM;QACtE,IAAI,CAAC,KAAK5B,UAAA,EAAY,KAAKF,QAAA,EAAU+B,QAAA,CAASH,aAAA,GAAgB;UAG5DD,SAAA,CAAUE,UAAA,GAAa;QAAA,OAEpB;UACH,OAAO,KAAKvE,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc2C,aAAA;QAAA;QAE1C,KAAKI,iBAAA,GAAoB;MAAA;IAAA;IAI7B,MAAMlD,SAAA,GAAY,KAAK3B,MAAA,CAAO8B,aAAA,CAAc,KAAKH,SAAA;IACjD,MAAMmD,aAAA,GAAgBnD,SAAA,CAAUoD,IAAA;IAChC,MAAMlD,cAAA,GAAiB,KAAKA,cAAA;IAC5B,MAAMG,SAAA,GAAY,KAAK/B,MAAA,CAAO6B,aAAA,CAAc,KAAKE,SAAA;IACjD,MAAMgD,aAAA,GAAgBhD,SAAA,CAAU+C,IAAA;IAChC,MAAM9C,cAAA,GAAiB,KAAKA,cAAA;IAC5B,MAAMgD,eAAA,GAAkBvE,cAAA;MAAEqE,IAAA,EAAMD;IAAA,GAAkB,KAAKb,mBAAA;IACvD,MAAMiB,eAAA,GAAkBxE,cAAA;MAAEqE,IAAA,EAAMC;IAAA,GAAkB,KAAKX,iBAAA;IAEvD,IAAI,KAAKQ,iBAAA,KAAsB,MAAM;MACnCK,eAAA,CAAgBR,UAAA,GAAaO,eAAA,CAAgBP,UAAA,GAAa;IAAA,WACjD,KAAKvE,OAAA,CAAQgF,MAAA,KAAW,OAAO;MACxC,IAAIC,SAAA;MACJ,IAAI,OAAO,KAAKlF,OAAA,CAAQkF,SAAA,KAAc,YAAY,KAAKlF,OAAA,CAAQkF,SAAA,KAAc,IAAI;QAC/EA,SAAA,GAAY,KAAKlF,OAAA,CAAQkF,SAAA;MAAA,OACpB;QACLA,SAAA,GAAY,CAAC,KAAKjF,OAAA,CAAQG,KAAA,CAAMgB,SAAA,EAAW,KAAKyB,UAAA,EAAY,KAAKF,QAAA,EAAU,UAAUuB,IAAA,CAAK;MAAA;MAE5Fc,eAAA,CAAgBC,MAAA,GAASF,eAAA,CAAgBE,MAAA,GAASC,SAAA;IAAA;IAGpD,IAAI,CAAC,KAAKjF,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKiB,UAAA,GAAa;MACtD,KAAK5C,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKiB,UAAA,IAAc;QAClD4B,cAAA,EAAgB;MAAA;IAAA;IAIpB,IAAI,CAAC,KAAKxE,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKe,QAAA,GAAW;MACpD,KAAK1C,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKe,QAAA,IAAY;QAChD8B,cAAA,EAAgB;MAAA;IAAA;IAIpB,IAAI,KAAKzE,OAAA,CAAQmF,WAAA,KAAgB,OAAO;MACtCJ,eAAA,CAAgBK,UAAA,GAAa;QAC3BhF,KAAA,EAAO,KAAKN,MAAA,CAAOuF,YAAA;QACnBC,GAAA,EAAK3D;MAAA;MAGPoD,eAAA,CAAgBQ,QAAA,GAAW,KAAKvF,OAAA,CAAQuF,QAAA,IAAY,KAAKtF,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKiB,UAAA,EAAY0C,QAAA;MACtGR,eAAA,CAAgBS,QAAA,GAAW,KAAKxF,OAAA,CAAQwF,QAAA,IAAY,KAAKvF,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKiB,UAAA,EAAY2C,QAAA;MAEtG,IAAI,CAACT,eAAA,CAAgBQ,QAAA,EAAUR,eAAA,CAAgBQ,QAAA,GAAW;MAC1D,IAAI,CAACR,eAAA,CAAgBS,QAAA,EAAUT,eAAA,CAAgBS,QAAA,GAAW;MAE1DR,eAAA,CAAgBI,UAAA,GAAa;QAC3BhF,KAAA,EAAO,KAAKL,MAAA,CAAOsF,YAAA;QACnBC,GAAA,EAAKvD;MAAA;MAGPiD,eAAA,CAAgBO,QAAA,GAAW,KAAKtF,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKe,QAAA,EAAU4C,QAAA,IAAY,KAAKvF,OAAA,CAAQuF,QAAA;MACpGP,eAAA,CAAgBQ,QAAA,GAAW,KAAKvF,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKe,QAAA,EAAU6C,QAAA,IAAY,KAAKxF,OAAA,CAAQwF,QAAA;MAEpG,IAAI,CAACR,eAAA,CAAgBO,QAAA,EAAUP,eAAA,CAAgBO,QAAA,GAAW;MAC1D,IAAI,CAACP,eAAA,CAAgBQ,QAAA,EAAUR,eAAA,CAAgBQ,QAAA,GAAW;IAAA;IAG5DpD,MAAA,CAAOC,MAAA,CAAO,KAAKpC,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKiB,UAAA,GAAakC,eAAA;IACjE3C,MAAA,CAAOC,MAAA,CAAO,KAAKpC,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKe,QAAA,GAAWqC,eAAA;IAE/D,KAAK/E,OAAA,CAAQG,KAAA,CAAMqF,iBAAA;IAEnB,KAAKC,eAAA,GAAkB,KAAKzF,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKiB,UAAA,EAAYhB,KAAA,IAAS,KAAKgB,UAAA;IACvF,KAAK8C,sBAAA,GAAyB,KAAK1F,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKe,QAAA,EAAUd,KAAA,IAAS,KAAKc,QAAA;IAK5F,IAAI,KAAK3C,OAAA,CAAQO,SAAA,CAAUP,OAAA,CAAQ4F,OAAA,KAAY,SAC3C,KAAK9F,MAAA,CAAO8B,aAAA,CAAc,KAAKH,SAAA,EAAW+C,UAAA,KAAe,MAAM;MACjE,KAAK1E,MAAA,CAAO8B,aAAA,CAAc,KAAKH,SAAA,EAAWwD,MAAA,GAAS;IAAA;IAGrD,IAAI,KAAKzD,MAAA,IAAU,CAAC,KAAKA,MAAA,CAAOmE,sBAAA,EAAwB;MACtD,KAAKnE,MAAA,CAAOmE,sBAAA,GAAyB,KAAK1F,OAAA,CAAQG,KAAA,CAAMwB,aAAA,CAAc,KAAKJ,MAAA,CAAOmB,QAAA,EAAUd,KAAA,IAAS,KAAKL,MAAA,CAAOmB,QAAA;IAAA;IAGnH,KAAKkD,QAAA,GAAW,IAAIvG,SAAA,CAAU,KAAKW,OAAA,CAAQG,KAAA,EAAO,KAAKN,MAAA,EAAQ;MAC7D+C,UAAA,EAAY,KAAKA;IAAA;IAEnB,KAAKiD,cAAA,GAAiB,IAAIvG,OAAA,CAAQ,KAAKO,MAAA,EAAQ,KAAKG,OAAA,CAAQG,KAAA,EAAO;MACjEyC,UAAA,EAAY,KAAKA;IAAA;IAEnB,KAAKkD,aAAA,GAAgB,IAAIvG,MAAA,CAAO,KAAKM,MAAA,EAAQ,KAAKG,OAAA,CAAQG,KAAA,EAAO;MAC/DyC,UAAA,EAAY,KAAKA,UAAA;MACjBpB,SAAA,EAAW,KAAKA,SAAA;MAChBd,EAAA,EAAI,KAAKV,OAAA,CAAQG,KAAA,CAAMD;IAAA;IAGzB,KAAK6F,QAAA,GAAW,IAAI1G,SAAA,CAAU,KAAKW,OAAA,CAAQG,KAAA,EAAO,KAAKL,MAAA,EAAQ;MAC7D8C,UAAA,EAAY,KAAKF;IAAA;IAEnB,KAAKsD,cAAA,GAAiB,IAAI1G,OAAA,CAAQ,KAAKQ,MAAA,EAAQ,KAAKE,OAAA,CAAQG,KAAA,EAAO;MACjEyC,UAAA,EAAY,KAAKF;IAAA;IAEnB,KAAKuD,aAAA,GAAgB,IAAI1G,MAAA,CAAO,KAAKO,MAAA,EAAQ,KAAKE,OAAA,CAAQG,KAAA,EAAO;MAC/DyC,UAAA,EAAY,KAAKF,QAAA;MACjBlB,SAAA,EAAW,KAAKK,SAAA;MAChBnB,EAAA,EAAI,KAAKV,OAAA,CAAQG,KAAA,CAAMD;IAAA;IAGzB,IAAI,KAAKqB,MAAA,IAAU,KAAKA,MAAA,CAAOoB,eAAA,EAAiB;MAC9C,KAAKpB,MAAA,CAAOwE,QAAA,GAAW,IAAI1G,SAAA,CAAU,KAAKkC,MAAA,CAAOvB,OAAA,CAAQG,KAAA,EAAO,KAAKoB,MAAA,CAAOzB,MAAA,EAAQ;QAClF8C,UAAA,EAAY,KAAKrB,MAAA,CAAOmB;MAAA;MAG1B,KAAKnB,MAAA,CAAO0E,aAAA,GAAgB,IAAI1G,MAAA,CAAO,KAAKgC,MAAA,CAAOzB,MAAA,EAAQ,KAAKyB,MAAA,CAAOvB,OAAA,CAAQG,KAAA,EAAO;QACpFyC,UAAA,EAAY,KAAKrB,MAAA,CAAOmB,QAAA;QACxBlB,SAAA,EAAW,KAAKD,MAAA,CAAOM,SAAA;QACvBnB,EAAA,EAAI,KAAKa,MAAA,CAAOvB,OAAA,CAAQG,KAAA,CAAMD;MAAA;IAAA;IAIlChB,OAAA,CAAQgH,oBAAA,CAAqB;IAE7B,OAAO;EAAA;EAGTC,MAAMC,GAAA,EAAK;IACT,MAAMC,OAAA,GAAU,CAAC,OAAO,SAAS,aAAa,UAAU,OAAO,OAAO,eAAe,UAAU,kBAAkB;IACjH,MAAMC,OAAA,GAAU;MACd5C,SAAA,EAAW;MACXC,MAAA,EAAQ;MACRN,WAAA,EAAa;MACbI,cAAA,EAAgB;IAAA;IAGlBvE,OAAA,CAAQqH,YAAA,CAAa,MAAMH,GAAA,EAAKC,OAAA,EAASC,OAAA;EAAA;EAAA,MAmBrCnD,IAAIqD,QAAA,EAAUzG,OAAA,EAAS;IAC3BA,OAAA,GAAUf,KAAA,CAAMyH,SAAA,CAAU1G,OAAA,KAAY;IAEtC,MAAMC,OAAA,GAAU,KAAKA,OAAA;IACrB,IAAI0G,UAAA;IACJ,IAAIC,YAAA;IAEJ,IAAI,KAAKC,KAAA,EAAO;MACdF,UAAA,GAAanG,cAAA,KAAK,KAAKqG,KAAA;IAAA;IAGzB7G,OAAA,CAAQ8G,KAAA,GAAQ;MAAA,CACbnH,EAAA,CAAGoH,GAAA,GAAM,CACRJ,UAAA,EACA3G,OAAA,CAAQ8G,KAAA;IAAA;IAIZ,IAAI1E,MAAA,CAAOnC,OAAA,CAAQG,KAAA,MAAWH,OAAA,CAAQG,KAAA,EAAO;MAC3CwG,YAAA,GAAe;MACfA,YAAA,CAAa,KAAK/D,UAAA,IAAc4D,QAAA,CAASrD,GAAA,CAAI,KAAK3B,SAAA;MAElD,IAAIxB,OAAA,CAAQ4G,KAAA,EAAO;QACjBzE,MAAA,CAAOC,MAAA,CAAOuE,YAAA,EAAc3G,OAAA,CAAQ4G,KAAA;MAAA;MAItC,IAAI7G,OAAA,CAAQC,OAAA,IAAWD,OAAA,CAAQC,OAAA,CAAQ6G,KAAA,EAAO;QAC5CF,YAAA,GAAe;UAAA,CACZjH,EAAA,CAAGoH,GAAA,GAAM,CAACH,YAAA,EAAc5G,OAAA,CAAQC,OAAA,CAAQ6G,KAAA;QAAA;MAAA;MAI7C9G,OAAA,CAAQgH,OAAA,GAAUhH,OAAA,CAAQgH,OAAA,IAAW;MACrChH,OAAA,CAAQgH,OAAA,CAAQC,IAAA,CAAK;QACnB1F,WAAA,EAAa,KAAK2E,aAAA;QAClBgB,UAAA,EAAYlH,OAAA,CAAQmH,mBAAA;QACpBC,QAAA,EAAU;QACV7E,QAAA,EAAUnD,CAAA,CAAEgE,GAAA,CAAIpD,OAAA,CAAQC,OAAA,EAAS,YAAY;QAC7C6G,KAAA,EAAOF;MAAA;IAAA;IAIX,IAAIxG,KAAA,GAAQ,KAAKL,MAAA;IACjB,IAAIqC,MAAA,CAAOiF,SAAA,CAAUC,cAAA,CAAeC,IAAA,CAAKvH,OAAA,EAAS,UAAU;MAC1D,IAAI,CAACA,OAAA,CAAQ6G,KAAA,EAAO;QAClBzG,KAAA,GAAQA,KAAA,CAAMoH,QAAA;MAAA,OACT;QACLpH,KAAA,GAAQA,KAAA,CAAMyG,KAAA,CAAM7G,OAAA,CAAQ6G,KAAA;MAAA;IAAA;IAIhC,IAAIzE,MAAA,CAAOiF,SAAA,CAAUC,cAAA,CAAeC,IAAA,CAAKvH,OAAA,EAAS,WAAW;MAC3DI,KAAA,GAAQA,KAAA,CAAMqH,MAAA,CAAOzH,OAAA,CAAQyH,MAAA,EAAQzH,OAAA,CAAQ0H,eAAA;IAAA;IAG/C,OAAOtH,KAAA,CAAMuH,OAAA,CAAQ3H,OAAA;EAAA;EAAA,MAajB6D,MAAM4C,QAAA,EAAUzG,OAAA,EAAS;IAC7B,MAAMO,SAAA,GAAY,KAAKR,MAAA,CAAOQ,SAAA;IAE9BP,OAAA,GAAUf,KAAA,CAAMyH,SAAA,CAAU1G,OAAA;IAC1BA,OAAA,CAAQkH,UAAA,GAAa,CACnB,CAAC3G,SAAA,CAAUqH,EAAA,CAAG,SAASrH,SAAA,CAAUsH,GAAA,CAAI,CAAC,KAAK9H,MAAA,CAAOI,IAAA,EAAM,KAAK4B,cAAA,EAAgBmC,IAAA,CAAK,QAAQ;IAE5FlE,OAAA,CAAQmH,mBAAA,GAAsB;IAC9BnH,OAAA,CAAQ8H,GAAA,GAAM;IACd9H,OAAA,CAAQ+H,KAAA,GAAQ;IAEhB,MAAMC,MAAA,GAAS,MAAM,KAAK5E,GAAA,CAAIqD,QAAA,EAAUzG,OAAA;IAExC,OAAOiI,QAAA,CAASD,MAAA,CAAOnE,KAAA,EAAO;EAAA;EAAA,MAY1BqE,IAAIC,cAAA,EAAgBC,SAAA,EAAWpI,OAAA,EAAS;IAC5C,IAAI,CAACqI,KAAA,CAAMC,OAAA,CAAQF,SAAA,GAAY;MAC7BA,SAAA,GAAY,CAACA,SAAA;IAAA;IAGfpI,OAAA,GAAUuI,aAAA,CAAA/H,cAAA;MACRsH,GAAA,EAAK;IAAA,GACF9H,OAAA,GAFK;MAGR6G,KAAA,EAAO;MACPK,UAAA,EAAY,CAAC,KAAKpF,SAAA;MAClBqF,mBAAA,EAAqB;IAAA;IAGvB,MAAMqB,mBAAA,GAAsBJ,SAAA,CAAUK,GAAA,CAAIhC,QAAA,IAAY;MACpD,IAAIA,QAAA,YAAoB,KAAK1G,MAAA,EAAQ;QACnC,OAAO0G,QAAA,CAASK,KAAA;MAAA;MAElB,OAAO;QAAA,CACJ,KAAKhF,SAAA,GAAY2E;MAAA;IAAA;IAItBzG,OAAA,CAAQ8G,KAAA,GAAQ;MAAA,CACbnH,EAAA,CAAGoH,GAAA,GAAM,CACR;QAAA,CAAGpH,EAAA,CAAG+I,EAAA,GAAKF;MAAA,GACXxI,OAAA,CAAQ8G,KAAA;IAAA;IAIZ,MAAM6B,iBAAA,GAAoB,MAAM,KAAKvF,GAAA,CAAI+E,cAAA,EAAgBnI,OAAA;IAEzD,OAAOZ,CAAA,CAAEwJ,cAAA,CAAeJ,mBAAA,EAAqBG,iBAAA,EAC3C,CAACE,CAAA,EAAGC,CAAA,KAAM1J,CAAA,CAAE2J,OAAA,CAAQF,CAAA,CAAE,KAAK/G,SAAA,GAAYgH,CAAA,CAAE,KAAKhH,SAAA,IAAakH,MAAA,KAAW;EAAA;EAAA,MAepE3F,IAAI8E,cAAA,EAAgBc,oBAAA,EAAsBjJ,OAAA,EAAS;IACvDA,OAAA,GAAUA,OAAA,IAAW;IAErB,MAAMyB,SAAA,GAAY,KAAKA,SAAA;IACvB,MAAMK,SAAA,GAAY,KAAKA,SAAA;IACvB,MAAMsC,UAAA,GAAa,KAAKA,UAAA;IACxB,MAAMC,iBAAA,GAAoB,KAAKA,iBAAA;IAE/B,IAAI4E,oBAAA,KAAyB,MAAM;MACjCA,oBAAA,GAAuB;IAAA,OAClB;MACLA,oBAAA,GAAuB,KAAKC,eAAA,CAAgBD,oBAAA;IAAA;IAE9C,MAAMnC,KAAA,GAAQtG,cAAA;MAAA,CACX4D,UAAA,GAAa+D,cAAA,CAAe/E,GAAA,CAAI3B,SAAA;IAAA,GAC9B,KAAKxB,OAAA,CAAQ4G,KAAA;IAGlB,MAAMsC,kBAAA,GAAqBC,WAAA,IAAe;MACxC,MAAMC,oBAAA,GAAuB;MAC7B,MAAMC,QAAA,GAAW;MACjB,MAAMC,iBAAA,GAAoBvJ,OAAA,CAAQC,OAAA,IAAW;MAE7C,MAAMuJ,mBAAA,GAAsBP,oBAAA,CAAqBQ,MAAA,CAAOpD,GAAA,IACtD,CAAC+C,WAAA,CAAYM,IAAA,CAAKC,UAAA,IAAcA,UAAA,CAAWtF,iBAAA,MAAuBgC,GAAA,CAAIjD,GAAA,CAAItB,SAAA;MAG5E,WAAW6H,UAAA,IAAcP,WAAA,EAAa;QACpC,MAAMQ,MAAA,GAASX,oBAAA,CAAqBY,IAAA,CAAKxD,GAAA,IAAOsD,UAAA,CAAWtF,iBAAA,MAAuBgC,GAAA,CAAIjD,GAAA,CAAItB,SAAA;QAE1F,IAAI,CAAC8H,MAAA,EAAQ;UACXP,oBAAA,CAAqBpC,IAAA,CAAK0C,UAAA;QAAA,OACrB;UACL,IAAIG,iBAAA,GAAoBF,MAAA,CAAO,KAAK3J,OAAA,CAAQG,KAAA,CAAMD,IAAA;UAElD,IAAI2J,iBAAA,YAA6B,KAAK7J,OAAA,CAAQG,KAAA,EAAO;YACnD0J,iBAAA,GAAoB;UAAA;UAGtB,MAAM5C,UAAA,GAAa1G,cAAA,CAAAA,cAAA,KAAK+I,iBAAA,GAAsBO,iBAAA;UAE9C,IAAI1H,MAAA,CAAO2H,IAAA,CAAK7C,UAAA,EAAY8B,MAAA,EAAQ;YAClCM,QAAA,CAASrC,IAAA,CACP,KAAKhH,OAAA,CAAQG,KAAA,CAAM4J,MAAA,CAAO9C,UAAA,EAAY9E,MAAA,CAAOC,MAAA,CAAOrC,OAAA,EAAS;cAC3D8G,KAAA,EAAO;gBAAA,CACJ1C,UAAA,GAAa+D,cAAA,CAAe/E,GAAA,CAAI3B,SAAA;gBAAA,CAChC4C,iBAAA,GAAoBuF,MAAA,CAAOxG,GAAA,CAAItB,SAAA;cAAA;YAAA;UAAA;QAAA;MAAA;MAS5C,IAAIuH,oBAAA,CAAqBL,MAAA,GAAS,GAAG;QACnCM,QAAA,CAASrC,IAAA,CACP,KAAKhH,OAAA,CAAQG,KAAA,CAAM6J,OAAA,CAAQ1B,aAAA,CAAA/H,cAAA,KACtBR,OAAA,GADsB;UAEzB8G,KAAA,EAAOtG,cAAA;YAAA,CACJ4D,UAAA,GAAa+D,cAAA,CAAe/E,GAAA,CAAI3B,SAAA;YAAA,CAChC4C,iBAAA,GAAoBgF,oBAAA,CAAqBZ,GAAA,CAAIyB,mBAAA,IAAuBA,mBAAA,CAAoB7F,iBAAA;UAAA,GACtF,KAAKpE,OAAA,CAAQ4G,KAAA;QAAA;MAAA;MAMxB,IAAI2C,mBAAA,CAAoBR,MAAA,GAAS,GAAG;QAClC,MAAMmB,IAAA,GAAOX,mBAAA,CAAoBf,GAAA,CAAI2B,kBAAA,IAAsB;UACzD,OAAO5J,cAAA,CAAA+H,aAAA,CAAA/H,cAAA,CAAAA,cAAA,KACF+I,iBAAA,GACAa,kBAAA,CAAmB,KAAKnK,OAAA,CAAQG,KAAA,CAAMD,IAAA,IAFpC;YAAA,CAGJiE,UAAA,GAAa+D,cAAA,CAAe/E,GAAA,CAAI3B,SAAA;YAAA,CAChC4C,iBAAA,GAAoB+F,kBAAA,CAAmBhH,GAAA,CAAItB,SAAA;UAAA,IACzC,KAAK7B,OAAA,CAAQ4G,KAAA;QAAA;QAIpByC,QAAA,CAASrC,IAAA,CAAK,KAAKhH,OAAA,CAAQG,KAAA,CAAMiK,UAAA,CAAWF,IAAA,EAAM3J,cAAA;UAAEgC,QAAA,EAAU;QAAA,GAASxC,OAAA;MAAA;MAGzE,OAAOsK,OAAA,CAAQC,GAAA,CAAIjB,QAAA;IAAA;IAGrB,IAAI;MACF,MAAMF,WAAA,GAAc,MAAM,KAAKnJ,OAAA,CAAQG,KAAA,CAAMuH,OAAA,CAAQY,aAAA,CAAA/H,cAAA,KAAKR,OAAA,GAAL;QAAc8G,KAAA;QAAOgB,GAAA,EAAK;MAAA;MAC/E,OAAO,MAAMqB,kBAAA,CAAmBC,WAAA;IAAA,SACzBoB,KAAA,EAAP;MACA,IAAIA,KAAA,YAAiB9K,gBAAA,EAAkB,OAAOyJ,kBAAA,CAAmB;MACjE,MAAMqB,KAAA;IAAA;EAAA;EAAA,MAgBJjH,IAAI4E,cAAA,EAAgBsC,YAAA,EAAczK,OAAA,EAAS;IAE/C,IAAI,CAACyK,YAAA,EAAc,OAAOH,OAAA,CAAQI,OAAA;IAElC1K,OAAA,GAAUQ,cAAA,KAAKR,OAAA;IAEf,MAAMuB,WAAA,GAAc;IACpB,MAAME,SAAA,GAAYF,WAAA,CAAYE,SAAA;IAC9B,MAAMK,SAAA,GAAYP,WAAA,CAAYO,SAAA;IAC9B,MAAMsC,UAAA,GAAa7C,WAAA,CAAY6C,UAAA;IAC/B,MAAMC,iBAAA,GAAoB9C,WAAA,CAAY8C,iBAAA;IACtC,MAAMkF,iBAAA,GAAoBvJ,OAAA,CAAQC,OAAA,IAAW;IAE7CwK,YAAA,GAAelJ,WAAA,CAAY2H,eAAA,CAAgBuB,YAAA;IAE3C,MAAM3D,KAAA,GAAQtG,cAAA;MAAA,CACX4D,UAAA,GAAa+D,cAAA,CAAe/E,GAAA,CAAI3B,SAAA;MAAA,CAChC4C,iBAAA,GAAoBoG,YAAA,CAAahC,GAAA,CAAIkC,WAAA,IAAeA,WAAA,CAAYvH,GAAA,CAAItB,SAAA;IAAA,GAClEP,WAAA,CAAYtB,OAAA,CAAQ4G,KAAA;IAGzB,MAAMsC,kBAAA,GAAqBC,WAAA,IAAe;MACxC,MAAME,QAAA,GAAW;MACjB,MAAME,mBAAA,GAAsB;MAC5B,MAAMoB,mBAAA,GAAsB;MAC5B,WAAWvE,GAAA,IAAOoE,YAAA,EAAc;QAC9B,MAAMI,mBAAA,GAAsBzB,WAAA,IAAeA,WAAA,CAAYS,IAAA,CAAKiB,OAAA,IAAWA,OAAA,CAAQzG,iBAAA,MAAuBgC,GAAA,CAAIjD,GAAA,CAAItB,SAAA;QAE9G,IAAI,CAAC+I,mBAAA,EAAqB;UACxBrB,mBAAA,CAAoBvC,IAAA,CAAKZ,GAAA;QAAA,OACpB;UACL,MAAMyD,iBAAA,GAAoBzD,GAAA,CAAI9E,WAAA,CAAYtB,OAAA,CAAQG,KAAA,CAAMD,IAAA;UACxD,MAAM+G,UAAA,GAAa1G,cAAA,CAAAA,cAAA,KAAK+I,iBAAA,GAAsBO,iBAAA;UAE9C,IAAI1H,MAAA,CAAO2H,IAAA,CAAK7C,UAAA,EAAYwC,IAAA,CAAKpF,SAAA,IAAa4C,UAAA,CAAW5C,SAAA,MAAeuG,mBAAA,CAAoBvG,SAAA,IAAa;YACvGsG,mBAAA,CAAoB3D,IAAA,CAAKZ,GAAA;UAAA;QAAA;MAAA;MAK/B,IAAImD,mBAAA,CAAoBR,MAAA,GAAS,GAAG;QAClC,MAAMmB,IAAA,GAAOX,mBAAA,CAAoBf,GAAA,CAAI2B,kBAAA,IAAsB;UACzD,MAAMN,iBAAA,GAAoBM,kBAAA,CAAmB7I,WAAA,CAAYtB,OAAA,CAAQG,KAAA,CAAMD,IAAA;UACvE,MAAM+G,UAAA,GAAa1G,cAAA,CAAAA,cAAA,KAAK+I,iBAAA,GAAsBO,iBAAA;UAE9C5C,UAAA,CAAW9C,UAAA,IAAc+D,cAAA,CAAe/E,GAAA,CAAI3B,SAAA;UAC5CyF,UAAA,CAAW7C,iBAAA,IAAqB+F,kBAAA,CAAmBhH,GAAA,CAAItB,SAAA;UAEvDM,MAAA,CAAOC,MAAA,CAAO6E,UAAA,EAAY3F,WAAA,CAAYtB,OAAA,CAAQ4G,KAAA;UAE9C,OAAOK,UAAA;QAAA;QAGToC,QAAA,CAASrC,IAAA,CAAK1F,WAAA,CAAYtB,OAAA,CAAQG,KAAA,CAAMiK,UAAA,CAAWF,IAAA,EAAM3J,cAAA;UAAEgC,QAAA,EAAU;QAAA,GAASxC,OAAA;MAAA;MAGhF,WAAW+K,KAAA,IAASH,mBAAA,EAAqB;QACvC,IAAId,iBAAA,GAAoBiB,KAAA,CAAMxJ,WAAA,CAAYtB,OAAA,CAAQG,KAAA,CAAMD,IAAA;QACxD,MAAM+G,UAAA,GAAa1G,cAAA,CAAAA,cAAA,KAAK+I,iBAAA,GAAsBO,iBAAA;QAE9C,IAAIA,iBAAA,YAA6BvI,WAAA,CAAYtB,OAAA,CAAQG,KAAA,EAAO;UAC1D0J,iBAAA,GAAoB;QAAA;QAGtBR,QAAA,CAASrC,IAAA,CAAK1F,WAAA,CAAYtB,OAAA,CAAQG,KAAA,CAAM4J,MAAA,CAAO9C,UAAA,EAAY9E,MAAA,CAAOC,MAAA,CAAOrC,OAAA,EAAS;UAAE8G,KAAA,EAAO;YAAA,CACxF1C,UAAA,GAAa+D,cAAA,CAAe/E,GAAA,CAAI3B,SAAA;YAAA,CAChC4C,iBAAA,GAAoB0G,KAAA,CAAM3H,GAAA,CAAItB,SAAA;UAAA;QAAA;MAAA;MAInC,OAAOwI,OAAA,CAAQC,GAAA,CAAIjB,QAAA;IAAA;IAGrB,IAAI;MACF,MAAMF,WAAA,GAAc,MAAM7H,WAAA,CAAYtB,OAAA,CAAQG,KAAA,CAAMuH,OAAA,CAAQY,aAAA,CAAA/H,cAAA,KAAKR,OAAA,GAAL;QAAc8G,KAAA;QAAOgB,GAAA,EAAK;MAAA;MACtF,MAAM,CAACxG,YAAA,IAAgB,MAAM6H,kBAAA,CAAmBC,WAAA;MAChD,OAAO9H,YAAA;IAAA,SACAkJ,KAAA,EAAP;MACA,IAAIA,KAAA,YAAiB9K,gBAAA,EAAkB,OAAOyJ,kBAAA;MAC9C,MAAMqB,KAAA;IAAA;EAAA;EAaV/G,OAAO0E,cAAA,EAAgB6C,oBAAA,EAAsBhL,OAAA,EAAS;IACpD,MAAMuB,WAAA,GAAc;IAEpBvB,OAAA,GAAUA,OAAA,IAAW;IAErBgL,oBAAA,GAAuBzJ,WAAA,CAAY2H,eAAA,CAAgB8B,oBAAA;IAEnD,MAAMlE,KAAA,GAAQ;MAAA,CACXvF,WAAA,CAAY6C,UAAA,GAAa+D,cAAA,CAAe/E,GAAA,CAAI7B,WAAA,CAAYE,SAAA;MAAA,CACxDF,WAAA,CAAY8C,iBAAA,GAAoB2G,oBAAA,CAAqBvC,GAAA,CAAIkC,WAAA,IAAeA,WAAA,CAAYvH,GAAA,CAAI7B,WAAA,CAAYO,SAAA;IAAA;IAGvG,OAAOP,WAAA,CAAYtB,OAAA,CAAQG,KAAA,CAAM6J,OAAA,CAAQ1B,aAAA,CAAA/H,cAAA,KAAKR,OAAA,GAAL;MAAc8G;IAAA;EAAA;EAAA,MAanDtD,OAAO2E,cAAA,EAAgB8C,MAAA,EAAQjL,OAAA,EAAS;IAC5C,MAAMuB,WAAA,GAAc;IAEpBvB,OAAA,GAAUA,OAAA,IAAW;IACrBiL,MAAA,GAASA,MAAA,IAAU;IAEnB,IAAI5C,KAAA,CAAMC,OAAA,CAAQtI,OAAA,GAAU;MAC1BA,OAAA,GAAU;QACRkL,MAAA,EAAQlL;MAAA;IAAA;IAIZ,IAAIuB,WAAA,CAAYsF,KAAA,EAAO;MACrBzE,MAAA,CAAOC,MAAA,CAAO4I,MAAA,EAAQ1J,WAAA,CAAYsF,KAAA;MAClC,IAAI7G,OAAA,CAAQkL,MAAA,EAAQ;QAClBlL,OAAA,CAAQkL,MAAA,GAASlL,OAAA,CAAQkL,MAAA,CAAOhL,MAAA,CAAOkC,MAAA,CAAO2H,IAAA,CAAKxI,WAAA,CAAYsF,KAAA;MAAA;IAAA;IAKnE,MAAMsE,mBAAA,GAAsB,MAAM5J,WAAA,CAAYxB,MAAA,CAAOyD,MAAA,CAAOyH,MAAA,EAAQjL,OAAA;IAEpE,MAAMmI,cAAA,CAAe5G,WAAA,CAAY4B,SAAA,CAAUI,GAAA,EAAK4H,mBAAA,EAAqB/L,CAAA,CAAEgM,IAAA,CAAKpL,OAAA,EAAS,CAAC;IACtF,OAAOmL,mBAAA;EAAA;EAGTE,uBAAuBC,KAAA,EAAO;IAC5B,IAAI,OAAOA,KAAA,KAAU,UAAU;MAC7B,OAAO,KAAK3K,EAAA,KAAO2K,KAAA;IAAA;IAGrB,IAAIA,KAAA,IAASA,KAAA,CAAMvK,MAAA,EAAQ;MACzB,OAAO,KAAKJ,EAAA,KAAO2K,KAAA,CAAMvK,MAAA;IAAA;IAG3B,OAAO,CAAC,KAAKF,SAAA;EAAA;AAAA;AAIjB0K,MAAA,CAAOC,OAAA,GAAU5L,aAAA;AACjB2L,MAAA,CAAOC,OAAA,CAAQ5L,aAAA,GAAgBA,aAAA;AAC/B2L,MAAA,CAAOC,OAAA,CAAQC,OAAA,GAAU7L,aAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}