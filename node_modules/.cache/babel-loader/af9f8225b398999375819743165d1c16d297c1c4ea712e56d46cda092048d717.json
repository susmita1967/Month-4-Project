{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isEnumType, isInputObjectType, isInterfaceType, isListType, isNamedType, isNonNullType, isObjectType, isRequiredArgument, isRequiredInputField, isScalarType, isUnionType } from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nvar BreakingChangeType;\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] = 'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] = 'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] = 'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] = 'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] = 'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\nexport { BreakingChangeType };\nvar DangerousChangeType;\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] = 'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] = 'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\nexport { DangerousChangeType };\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in BreakingChangeType);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in DangerousChangeType);\n}\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [...findTypeChanges(oldSchema, newSchema), ...findDirectiveChanges(oldSchema, newSchema)];\n}\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: \"\".concat(oldDirective.name, \" was removed.\")\n    });\n  }\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: \"A required arg \".concat(newArg.name, \" on directive \").concat(oldDirective.name, \" was added.\")\n        });\n      }\n    }\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: \"\".concat(oldArg.name, \" was removed from \").concat(oldDirective.name, \".\")\n      });\n    }\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: \"Repeatable flag was removed from \".concat(oldDirective.name, \".\")\n      });\n    }\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: \"\".concat(location, \" was removed from \").concat(oldDirective.name, \".\")\n        });\n      }\n    }\n  }\n  return schemaChanges;\n}\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType) ? \"Standard scalar \".concat(oldType.name, \" was removed because it is not referenced anymore.\") : \"\".concat(oldType.name, \" was removed.\")\n    });\n  }\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: \"A required field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: \"An optional field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    }\n  }\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" changed type from \") + \"\".concat(String(oldField.type), \" to \").concat(String(newField.type), \".\")\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: \"\".concat(newPossibleType.name, \" was added to union type \").concat(oldType.name, \".\")\n    });\n  }\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: \"\".concat(oldPossibleType.name, \" was removed from union type \").concat(oldType.name, \".\")\n    });\n  }\n  return schemaChanges;\n}\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: \"\".concat(newValue.name, \" was added to enum type \").concat(oldType.name, \".\")\n    });\n  }\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: \"\".concat(oldValue.name, \" was removed from enum type \").concat(oldType.name, \".\")\n    });\n  }\n  return schemaChanges;\n}\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: \"\".concat(newInterface.name, \" added to interfaces implemented by \").concat(oldType.name, \".\")\n    });\n  }\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: \"\".concat(oldType.name, \" no longer implements interface \").concat(oldInterface.name, \".\")\n    });\n  }\n  return schemaChanges;\n}\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" changed type from \") + \"\".concat(String(oldField.type), \" to \").concat(String(newField.type), \".\")\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" was removed.\")\n    });\n  }\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" has changed type from \") + \"\".concat(String(oldArg.type), \" to \").concat(String(newArg.type), \".\")\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" defaultValue was removed.\")\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" has changed defaultValue from \").concat(oldValueStr, \" to \").concat(newValueStr, \".\")\n          });\n        }\n      }\n    }\n  }\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: \"A required arg \".concat(newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: \"An optional arg \".concat(newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) ||\n      // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n  return (\n    // if they're both named types, see if their names are equivalent\n    isNamedType(newType) && oldType.name === newType.name ||\n    // moving from nullable to non-null of the same underlying type is safe\n    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) ||\n      // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, _ref => {\n    let {\n      name\n    } = _ref;\n    return name;\n  });\n  const newMap = keyMap(newArray, _ref2 => {\n    let {\n      name\n    } = _ref2;\n    return name;\n  });\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n  return {\n    added,\n    persisted,\n    removed\n  };\n}","map":{"version":3,"names":["inspect","invariant","keyMap","print","isEnumType","isInputObjectType","isInterfaceType","isListType","isNamedType","isNonNullType","isObjectType","isRequiredArgument","isRequiredInputField","isScalarType","isUnionType","isSpecifiedScalarType","astFromValue","sortValueNode","BreakingChangeType","DangerousChangeType","findBreakingChanges","oldSchema","newSchema","findSchemaChanges","filter","change","type","findDangerousChanges","findTypeChanges","findDirectiveChanges","schemaChanges","directivesDiff","diff","getDirectives","oldDirective","removed","push","DIRECTIVE_REMOVED","description","concat","name","newDirective","persisted","argsDiff","args","newArg","added","REQUIRED_DIRECTIVE_ARG_ADDED","oldArg","DIRECTIVE_ARG_REMOVED","isRepeatable","DIRECTIVE_REPEATABLE_REMOVED","location","locations","includes","DIRECTIVE_LOCATION_REMOVED","typesDiff","Object","values","getTypeMap","oldType","TYPE_REMOVED","newType","findEnumTypeChanges","findUnionTypeChanges","findInputObjectTypeChanges","findFieldChanges","findImplementedInterfacesChanges","constructor","TYPE_CHANGED_KIND","typeKindName","fieldsDiff","getFields","newField","REQUIRED_INPUT_FIELD_ADDED","OPTIONAL_INPUT_FIELD_ADDED","oldField","FIELD_REMOVED","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","FIELD_CHANGED_KIND","String","possibleTypesDiff","getTypes","newPossibleType","TYPE_ADDED_TO_UNION","oldPossibleType","TYPE_REMOVED_FROM_UNION","valuesDiff","getValues","newValue","VALUE_ADDED_TO_ENUM","oldValue","VALUE_REMOVED_FROM_ENUM","interfacesDiff","getInterfaces","newInterface","IMPLEMENTED_INTERFACE_ADDED","oldInterface","IMPLEMENTED_INTERFACE_REMOVED","findArgChanges","isChangeSafeForObjectOrInterfaceField","ARG_REMOVED","ARG_CHANGED_KIND","defaultValue","undefined","ARG_DEFAULT_VALUE_CHANGE","oldValueStr","stringifyValue","newValueStr","REQUIRED_ARG_ADDED","OPTIONAL_ARG_ADDED","ofType","value","ast","oldArray","newArray","oldMap","_ref","newMap","_ref2","oldItem","newItem"],"sources":["E:/Sankey_Project/node_modules/graphql/utilities/findBreakingChanges.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nvar BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport { BreakingChangeType };\nvar DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\nexport { DangerousChangeType };\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}