{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nclass Transaction {\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n    this.options = __spreadValues({\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options);\n    this.parent = this.options.transaction;\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = \"\".concat(this.id, \"-sp-\").concat(this.parent.savepoints.length);\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n    delete this.options.transaction;\n  }\n  async commit() {\n    if (this.finished) {\n      throw new Error(\"Transaction cannot be committed because it has been finished with state: \".concat(this.finished));\n    }\n    try {\n      await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(\"Committing transaction \".concat(this.id, \" failed with error \").concat(JSON.stringify(e.message), \". We are killing its connection as it is now in an undetermined state.\"));\n      await this.forceCleanup();\n      throw e;\n    } finally {\n      this.finished = \"commit\";\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n  async rollback() {\n    if (this.finished) {\n      throw new Error(\"Transaction cannot be rolled back because it has been finished with state: \".concat(this.finished));\n    }\n    if (!this.connection) {\n      throw new Error(\"Transaction cannot be rolled back because it never started\");\n    }\n    try {\n      await this.sequelize.getQueryInterface().rollbackTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(\"Rolling back transaction \".concat(this.id, \" failed with error \").concat(JSON.stringify(e.message), \". We are killing its connection as it is now in an undetermined state.\"));\n      await this.forceCleanup();\n      throw e;\n    }\n  }\n  async prepareEnvironment() {\n    let useCLS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let connectionPromise;\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = {\n        uuid: this.id\n      };\n      if (this.options.readOnly) {\n        acquireOptions.type = \"SELECT\";\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr;\n      }\n    }\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set(\"transaction\", this);\n    }\n    return result;\n  }\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n    }\n  }\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    return queryInterface.startTransaction(this, this.options);\n  }\n  cleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  async forceCleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    await this.sequelize.connectionManager.destroyConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n    if (cls) {\n      if (cls.get(\"transaction\") === this) {\n        cls.set(\"transaction\", null);\n      }\n    }\n  }\n  afterCommit(fn) {\n    if (!fn || typeof fn !== \"function\") {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n  static get TYPES() {\n    return {\n      DEFERRED: \"DEFERRED\",\n      IMMEDIATE: \"IMMEDIATE\",\n      EXCLUSIVE: \"EXCLUSIVE\"\n    };\n  }\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: \"READ UNCOMMITTED\",\n      READ_COMMITTED: \"READ COMMITTED\",\n      REPEATABLE_READ: \"REPEATABLE READ\",\n      SERIALIZABLE: \"SERIALIZABLE\"\n    };\n  }\n  static get LOCK() {\n    return {\n      UPDATE: \"UPDATE\",\n      SHARE: \"SHARE\",\n      KEY_SHARE: \"KEY SHARE\",\n      NO_KEY_UPDATE: \"NO KEY UPDATE\"\n    };\n  }\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;","map":{"version":3,"names":["Transaction","constructor","sequelize","options","savepoints","_afterCommitHooks","generateTransactionId","dialect","queryGenerator","__spreadValues","type","transactionType","isolationLevel","readOnly","parent","transaction","id","push","name","concat","length","commit","finished","Error","getQueryInterface","commitTransaction","cleanup","e","console","warn","JSON","stringify","message","forceCleanup","hook","apply","rollback","connection","rollbackTransaction","prepareEnvironment","useCLS","arguments","undefined","connectionPromise","Promise","resolve","acquireOptions","uuid","connectionManager","getConnection","result","begin","setDeferrable","setupErr","_cls","set","deferrable","deferConstraints","queryInterface","supports","settingIsolationLevelDuringTransaction","startTransaction","setIsolationLevel","_clearCls","releaseConnection","destroyConnection","cls","get","afterCommit","fn","TYPES","DEFERRED","IMMEDIATE","EXCLUSIVE","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","SERIALIZABLE","LOCK","UPDATE","SHARE","KEY_SHARE","NO_KEY_UPDATE","module","exports","default"],"sources":["E:\\Sankey_Project\\node_modules\\sequelize\\src\\transaction.js"],"sourcesContent":["'use strict';\n\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {@link Sequelize.transaction}\n */\nclass Transaction {\n  /**\n   * Creates a new transaction instance\n   *\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {object} options An object with options\n   * @param {string} [options.type] Sets the type of the transaction. Sqlite only\n   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   * @param {boolean} [options.readOnly] Whether this transaction will only be used to read data. Used to determine whether sequelize is allowed to use a read replication server.\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n\n    // get dialect specific transaction options\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n\n    this.options = {\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false,\n      ...options\n    };\n\n    this.parent = this.options.transaction;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction\n   *\n   * @returns {Promise}\n   */\n  async commit() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n\n    try {\n      await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Committing transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n\n      throw e;\n    } finally {\n      this.finished = 'commit';\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @returns {Promise}\n   */\n  async rollback() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n\n    if (!this.connection) {\n      throw new Error('Transaction cannot be rolled back because it never started');\n    }\n\n    try {\n      await this\n        .sequelize\n        .getQueryInterface()\n        .rollbackTransaction(this, this.options);\n\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Rolling back transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n\n      throw e;\n    }\n  }\n\n  /**\n   * Called to acquire a connection to use and set the correct options on the connection.\n   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.\n   *\n   * @param {boolean} useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.\n   * @returns {Promise}\n   */\n  async prepareEnvironment(useCLS = true) {\n    let connectionPromise;\n\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr; // eslint-disable-line no-unsafe-finally\n      }\n    }\n\n    // TODO (@ephys) [>=7.0.0]: move this inside of sequelize.transaction, remove parameter.\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set('transaction', this);\n    }\n\n    return result;\n  }\n\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n\n    return queryInterface.startTransaction(this, this.options);\n  }\n\n  cleanup() {\n    // Don't release the connection if there's a parent transaction or\n    // if we've already cleaned up\n    if (this.parent || this.connection.uuid === undefined) {\n      return;\n    }\n\n    this._clearCls();\n    this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n  }\n\n  /**\n   * Kills the connection this transaction uses.\n   * Used as a last resort, for instance because COMMIT or ROLLBACK resulted in an error\n   * and the transaction is left in a broken state,\n   * and releasing the connection to the pool would be dangerous.\n   */\n  async forceCleanup() {\n    // Don't release the connection if there's a parent transaction or\n    // if we've already cleaned up\n    if (this.parent || this.connection.uuid === undefined) {\n      return;\n    }\n\n    this._clearCls();\n    await this.sequelize.connectionManager.destroyConnection(this.connection);\n    this.connection.uuid = undefined;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {\n   *      // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *     // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   *\n   * # UserModel will be locked but TaskModel won't!\n   *\n   * @example <caption>You can also skip locked rows:</caption>\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * # The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns {object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n\n  /**\n   * Please see {@link Transaction.LOCK}\n   */\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAUA,MAAAA,WAAA,CAAkB;EAWhBC,YAAYC,SAAA,EAAWC,OAAA,EAAS;IAC9B,KAAKD,SAAA,GAAYA,SAAA;IACjB,KAAKE,UAAA,GAAa;IAClB,KAAKC,iBAAA,GAAoB;IAGzB,MAAMC,qBAAA,GAAwB,KAAKJ,SAAA,CAAUK,OAAA,CAAQC,cAAA,CAAeF,qBAAA;IAEpE,KAAKH,OAAA,GAAUM,cAAA;MACbC,IAAA,EAAMR,SAAA,CAAUC,OAAA,CAAQQ,eAAA;MACxBC,cAAA,EAAgBV,SAAA,CAAUC,OAAA,CAAQS,cAAA;MAClCC,QAAA,EAAU;IAAA,GACPV,OAAA;IAGL,KAAKW,MAAA,GAAS,KAAKX,OAAA,CAAQY,WAAA;IAE3B,IAAI,KAAKD,MAAA,EAAQ;MACf,KAAKE,EAAA,GAAK,KAAKF,MAAA,CAAOE,EAAA;MACtB,KAAKF,MAAA,CAAOV,UAAA,CAAWa,IAAA,CAAK;MAC5B,KAAKC,IAAA,MAAAC,MAAA,CAAU,KAAKH,EAAA,UAAAG,MAAA,CAAS,KAAKL,MAAA,CAAOV,UAAA,CAAWgB,MAAA;IAAA,OAC/C;MACL,KAAKJ,EAAA,GAAK,KAAKE,IAAA,GAAOZ,qBAAA;IAAA;IAGxB,OAAO,KAAKH,OAAA,CAAQY,WAAA;EAAA;EAAA,MAQhBM,OAAA,EAAS;IACb,IAAI,KAAKC,QAAA,EAAU;MACjB,MAAM,IAAIC,KAAA,6EAAAJ,MAAA,CAAkF,KAAKG,QAAA;IAAA;IAGnG,IAAI;MACF,MAAM,KAAKpB,SAAA,CAAUsB,iBAAA,GAAoBC,iBAAA,CAAkB,MAAM,KAAKtB,OAAA;MACtE,KAAKuB,OAAA;IAAA,SACEC,CAAA,EAAP;MACAC,OAAA,CAAQC,IAAA,2BAAAV,MAAA,CAA+B,KAAKH,EAAA,yBAAAG,MAAA,CAAwBW,IAAA,CAAKC,SAAA,CAAUJ,CAAA,CAAEK,OAAA;MACrF,MAAM,KAAKC,YAAA;MAEX,MAAMN,CAAA;IAAA,UACN;MACA,KAAKL,QAAA,GAAW;MAChB,WAAWY,IAAA,IAAQ,KAAK7B,iBAAA,EAAmB;QACzC,MAAM6B,IAAA,CAAKC,KAAA,CAAM,MAAM,CAAC;MAAA;IAAA;EAAA;EAAA,MAUxBC,SAAA,EAAW;IACf,IAAI,KAAKd,QAAA,EAAU;MACjB,MAAM,IAAIC,KAAA,+EAAAJ,MAAA,CAAoF,KAAKG,QAAA;IAAA;IAGrG,IAAI,CAAC,KAAKe,UAAA,EAAY;MACpB,MAAM,IAAId,KAAA,CAAM;IAAA;IAGlB,IAAI;MACF,MAAM,KACHrB,SAAA,CACAsB,iBAAA,GACAc,mBAAA,CAAoB,MAAM,KAAKnC,OAAA;MAElC,KAAKuB,OAAA;IAAA,SACEC,CAAA,EAAP;MACAC,OAAA,CAAQC,IAAA,6BAAAV,MAAA,CAAiC,KAAKH,EAAA,yBAAAG,MAAA,CAAwBW,IAAA,CAAKC,SAAA,CAAUJ,CAAA,CAAEK,OAAA;MACvF,MAAM,KAAKC,YAAA;MAEX,MAAMN,CAAA;IAAA;EAAA;EAAA,MAWJY,mBAAA,EAAkC;IAAA,IAAfC,MAAA,GAAAC,SAAA,CAAArB,MAAA,QAAAqB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAS;IAChC,IAAIE,iBAAA;IAEJ,IAAI,KAAK7B,MAAA,EAAQ;MACf6B,iBAAA,GAAoBC,OAAA,CAAQC,OAAA,CAAQ,KAAK/B,MAAA,CAAOuB,UAAA;IAAA,OAC3C;MACL,MAAMS,cAAA,GAAiB;QAAEC,IAAA,EAAM,KAAK/B;MAAA;MACpC,IAAI,KAAKb,OAAA,CAAQU,QAAA,EAAU;QACzBiC,cAAA,CAAepC,IAAA,GAAO;MAAA;MAExBiC,iBAAA,GAAoB,KAAKzC,SAAA,CAAU8C,iBAAA,CAAkBC,aAAA,CAAcH,cAAA;IAAA;IAGrE,IAAII,MAAA;IACJ,MAAMb,UAAA,GAAa,MAAMM,iBAAA;IACzB,KAAKN,UAAA,GAAaA,UAAA;IAClB,KAAKA,UAAA,CAAWU,IAAA,GAAO,KAAK/B,EAAA;IAE5B,IAAI;MACF,MAAM,KAAKmC,KAAA;MACXD,MAAA,GAAS,MAAM,KAAKE,aAAA;IAAA,SACbC,QAAA,EAAP;MACA,IAAI;QACFH,MAAA,GAAS,MAAM,KAAKd,QAAA;MAAA,UACpB;QACA,MAAMiB,QAAA;MAAA;IAAA;IAKV,IAAIb,MAAA,IAAU,KAAKtC,SAAA,CAAUD,WAAA,CAAYqD,IAAA,EAAM;MAC7C,KAAKpD,SAAA,CAAUD,WAAA,CAAYqD,IAAA,CAAKC,GAAA,CAAI,eAAe;IAAA;IAGrD,OAAOL,MAAA;EAAA;EAAA,MAGHE,cAAA,EAAgB;IACpB,IAAI,KAAKjD,OAAA,CAAQqD,UAAA,EAAY;MAC3B,OAAO,MAAM,KACVtD,SAAA,CACAsB,iBAAA,GACAiC,gBAAA,CAAiB,MAAM,KAAKtD,OAAA;IAAA;EAAA;EAAA,MAI7BgD,MAAA,EAAQ;IACZ,MAAMO,cAAA,GAAiB,KAAKxD,SAAA,CAAUsB,iBAAA;IAEtC,IAAK,KAAKtB,SAAA,CAAUK,OAAA,CAAQoD,QAAA,CAASC,sCAAA,EAAyC;MAC5E,MAAMF,cAAA,CAAeG,gBAAA,CAAiB,MAAM,KAAK1D,OAAA;MACjD,OAAOuD,cAAA,CAAeI,iBAAA,CAAkB,MAAM,KAAK3D,OAAA,CAAQS,cAAA,EAAgB,KAAKT,OAAA;IAAA;IAGlF,MAAMuD,cAAA,CAAeI,iBAAA,CAAkB,MAAM,KAAK3D,OAAA,CAAQS,cAAA,EAAgB,KAAKT,OAAA;IAE/E,OAAOuD,cAAA,CAAeG,gBAAA,CAAiB,MAAM,KAAK1D,OAAA;EAAA;EAGpDuB,QAAA,EAAU;IAGR,IAAI,KAAKZ,MAAA,IAAU,KAAKuB,UAAA,CAAWU,IAAA,KAAS,QAAW;MACrD;IAAA;IAGF,KAAKgB,SAAA;IACL,KAAK7D,SAAA,CAAU8C,iBAAA,CAAkBgB,iBAAA,CAAkB,KAAK3B,UAAA;IACxD,KAAKA,UAAA,CAAWU,IAAA,GAAO;EAAA;EAAA,MASnBd,aAAA,EAAe;IAGnB,IAAI,KAAKnB,MAAA,IAAU,KAAKuB,UAAA,CAAWU,IAAA,KAAS,QAAW;MACrD;IAAA;IAGF,KAAKgB,SAAA;IACL,MAAM,KAAK7D,SAAA,CAAU8C,iBAAA,CAAkBiB,iBAAA,CAAkB,KAAK5B,UAAA;IAC9D,KAAKA,UAAA,CAAWU,IAAA,GAAO;EAAA;EAGzBgB,UAAA,EAAY;IACV,MAAMG,GAAA,GAAM,KAAKhE,SAAA,CAAUD,WAAA,CAAYqD,IAAA;IAEvC,IAAIY,GAAA,EAAK;MACP,IAAIA,GAAA,CAAIC,GAAA,CAAI,mBAAmB,MAAM;QACnCD,GAAA,CAAIX,GAAA,CAAI,eAAe;MAAA;IAAA;EAAA;EAY7Ba,YAAYC,EAAA,EAAI;IACd,IAAI,CAACA,EAAA,IAAM,OAAOA,EAAA,KAAO,YAAY;MACnC,MAAM,IAAI9C,KAAA,CAAM;IAAA;IAElB,KAAKlB,iBAAA,CAAkBY,IAAA,CAAKoD,EAAA;EAAA;EAAA,WAwBnBC,MAAA,EAAQ;IACjB,OAAO;MACLC,QAAA,EAAU;MACVC,SAAA,EAAW;MACXC,SAAA,EAAW;IAAA;EAAA;EAAA,WAyBJC,iBAAA,EAAmB;IAC5B,OAAO;MACLC,gBAAA,EAAkB;MAClBC,cAAA,EAAgB;MAChBC,eAAA,EAAiB;MACjBC,YAAA,EAAc;IAAA;EAAA;EAAA,WA6CPC,KAAA,EAAO;IAChB,OAAO;MACLC,MAAA,EAAQ;MACRC,KAAA,EAAO;MACPC,SAAA,EAAW;MACXC,aAAA,EAAe;IAAA;EAAA;EAAA,IAOfJ,KAAA,EAAO;IACT,OAAO/E,WAAA,CAAY+E,IAAA;EAAA;AAAA;AAIvBK,MAAA,CAAOC,OAAA,GAAUrF,WAAA;AACjBoF,MAAA,CAAOC,OAAA,CAAQrF,WAAA,GAAcA,WAAA;AAC7BoF,MAAA,CAAOC,OAAA,CAAQC,OAAA,GAAUtF,WAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}