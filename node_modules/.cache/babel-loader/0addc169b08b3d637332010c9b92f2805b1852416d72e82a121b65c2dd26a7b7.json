{"ast":null,"code":"\"use strict\";\n\nconst util = require(\"util\");\nconst _ = require(\"lodash\");\nconst wkx = require(\"wkx\");\nconst sequelizeErrors = require(\"./errors\");\nconst Validator = require(\"./utils/validator-extras\").validator;\nconst momentTz = require(\"moment-timezone\");\nconst moment = require(\"moment\");\nconst {\n  logger\n} = require(\"./utils/logger\");\nconst warnings = {};\nconst {\n  classToInvokable\n} = require(\"./utils/class-to-invokable\");\nconst {\n  joinSQLFragments\n} = require(\"./utils/join-sql-fragments\");\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(\"\".concat(text, \" \\n>> Check: \").concat(link));\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\nABSTRACT.prototype.dialectTypes = \"\";\nclass STRING extends ABSTRACT {\n  constructor(length, binary) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length,\n      binary\n    };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return joinSQLFragments([\"VARCHAR(\".concat(this._length, \")\"), this._binary && \"BINARY\"]);\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== \"[object String]\") {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === \"number\") {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\nclass CHAR extends STRING {\n  constructor(length, binary) {\n    super(typeof length === \"object\" && length || {\n      length,\n      binary\n    });\n  }\n  toSql() {\n    return joinSQLFragments([\"CHAR(\".concat(this._length, \")\"), this._binary && \"BINARY\"]);\n  }\n}\nclass TEXT extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length\n    };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYTEXT\";\n      case \"medium\":\n        return \"MEDIUMTEXT\";\n      case \"long\":\n        return \"LONGTEXT\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return \"CITEXT\";\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass NUMBER extends ABSTRACT {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    if (typeof options === \"number\") {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += \"(\".concat(this._length);\n      if (typeof this._decimals === \"number\") {\n        result += \",\".concat(this._decimals);\n      }\n      result += \")\";\n    }\n    if (this._unsigned) {\n      result += \" UNSIGNED\";\n    }\n    if (this._zerofill) {\n      result += \" ZEROFILL\";\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid \".concat(this.key.toLowerCase()), value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === \"number\" || typeof number === \"bigint\" || typeof number === \"boolean\" || number === null || number === void 0) {\n      return number;\n    }\n    if (typeof number.toString === \"function\") {\n      return number.toString();\n    }\n    return number;\n  }\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid \".concat(this.key.toLowerCase()), value));\n    }\n    return true;\n  }\n}\nclass TINYINT extends INTEGER {}\nclass SMALLINT extends INTEGER {}\nclass MEDIUMINT extends INTEGER {}\nclass BIGINT extends INTEGER {}\nclass FLOAT extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || {\n      length,\n      decimals\n    });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid float\", value));\n    }\n    return true;\n  }\n}\nclass REAL extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || {\n      length,\n      decimals\n    });\n  }\n}\nclass DOUBLE extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || {\n      length,\n      decimals\n    });\n  }\n}\nclass DECIMAL extends NUMBER {\n  constructor(precision, scale) {\n    super(typeof precision === \"object\" && precision || {\n      precision,\n      scale\n    });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return \"DECIMAL(\".concat([this._precision, this._scale].filter(_.identity).join(\",\"), \")\");\n    }\n    return \"DECIMAL\";\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid decimal\", value));\n    }\n    return true;\n  }\n}\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return \"NaN\";\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? \"-\" : \"\";\n      return \"\".concat(sign, \"Infinity\");\n    }\n    return value;\n  },\n  _stringify(value) {\n    return \"'\".concat(this._value(value), \"'\");\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return \"TINYINT(1)\";\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid boolean\", value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== void 0) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === \"string\") {\n        return value === \"true\" ? true : value === \"false\" ? false : value;\n      }\n      if (type === \"number\") {\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\nclass TIME extends ABSTRACT {\n  toSql() {\n    return \"TIME\";\n  }\n}\nclass DATE extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length\n    };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    return \"DATETIME\";\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid date\", value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && (value === originalValue || value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    if (!moment.isMoment(date)) {\n      date = this._applyTimezone(date, options);\n    }\n    return date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n  }\n}\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return \"DATE\";\n  }\n  _stringify(date) {\n    return moment(date).format(\"YYYY-MM-DD\");\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid hstore\", value));\n    }\n    return true;\n  }\n}\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\nclass JSONB extends JSONTYPE {}\nclass NOW extends ABSTRACT {}\nclass BLOB extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length\n    };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYBLOB\";\n      case \"medium\":\n        return \"MEDIUMBLOB\";\n      case \"long\":\n        return \"LONGBLOB\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\" && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid blob\", value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString(\"hex\");\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return \"X'\".concat(hex, \"'\");\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\nBLOB.prototype.escape = false;\nclass RANGE extends ABSTRACT {\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : {\n      subtype\n    };\n    if (!options.subtype) options.subtype = new INTEGER();\n    if (typeof options.subtype === \"function\") {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid range\", value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError(\"A range must be an array with two elements\");\n    }\n    return true;\n  }\n}\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuidv4\", value));\n    }\n    return true;\n  }\n}\nclass VIRTUAL extends ABSTRACT {\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === \"function\") ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\nclass ENUM extends ABSTRACT {\n  constructor() {\n    super();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const value = args[0];\n    const options = typeof value === \"object\" && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid choice in %j\", value, this.values));\n    }\n    return true;\n  }\n}\nclass ARRAY extends ABSTRACT {\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : {\n      type\n    };\n    this.options = options;\n    this.type = typeof options.type === \"function\" ? new options.type() : options.type;\n  }\n  toSql() {\n    return \"\".concat(this.type.toSql(), \"[]\");\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid array\", value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\nclass GEOMETRY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : {\n      type,\n      srid\n    };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return \"ST_GeomFromText(\".concat(options.escape(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n  }\n  _bindParam(value, options) {\n    return \"ST_GeomFromText(\".concat(options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n  }\n}\nGEOMETRY.prototype.escape = false;\nclass GEOGRAPHY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : {\n      type,\n      srid\n    };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return \"ST_GeomFromText(\".concat(options.escape(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n  }\n  _bindParam(value, options) {\n    return \"ST_GeomFromText(\".concat(options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n  }\n}\nGEOGRAPHY.prototype.escape = false;\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid CIDR\", value));\n    }\n    return true;\n  }\n}\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid INET\", value));\n    }\n    return true;\n  }\n}\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid MACADDR\", value));\n    }\n    return true;\n  }\n}\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  \"DOUBLE PRECISION\": DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n_.each(DataTypes, (dataType, name) => {\n  if (!Object.prototype.hasOwnProperty.call(dataType, \"key\")) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\nconst dialectMap = {};\ndialectMap.postgres = require(\"./dialects/postgres/data-types\")(DataTypes);\ndialectMap.mysql = require(\"./dialects/mysql/data-types\")(DataTypes);\ndialectMap.mariadb = require(\"./dialects/mariadb/data-types\")(DataTypes);\ndialectMap.sqlite = require(\"./dialects/sqlite/data-types\")(DataTypes);\ndialectMap.mssql = require(\"./dialects/mssql/data-types\")(DataTypes);\ndialectMap.db2 = require(\"./dialects/db2/data-types\")(DataTypes);\ndialectMap.snowflake = require(\"./dialects/snowflake/data-types\")(DataTypes);\ndialectMap.oracle = require(\"./dialects/oracle/data-types\")(DataTypes);\nconst dialectList = Object.values(dialectMap);\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\nObject.assign(DataTypes, dialectMap);","map":{"version":3,"names":["util","require","_","wkx","sequelizeErrors","Validator","validator","momentTz","moment","logger","warnings","classToInvokable","joinSQLFragments","ABSTRACT","toString","options","toSql","key","stringify","value","_stringify","bindParam","_bindParam","name","warn","link","text","concat","extend","oldType","prototype","dialectTypes","STRING","constructor","length","binary","_binary","_length","validate","Object","call","Buffer","isBuffer","ValidationError","format","BINARY","CHAR","TEXT","toLowerCase","CITEXT","NUMBER","arguments","undefined","_zerofill","zerofill","_decimals","decimals","_precision","precision","_scale","scale","_unsigned","unsigned","result","isFloat","String","number","UNSIGNED","ZEROFILL","INTEGER","isInt","TINYINT","SMALLINT","MEDIUMINT","BIGINT","FLOAT","REAL","DOUBLE","DECIMAL","filter","identity","join","isDecimal","protoExtensions","escape","_value","isNaN","isFinite","sign","floating","assign","BOOLEAN","isBoolean","_sanitize","type","parse","TIME","DATE","isDate","raw","Date","_isChanged","originalValue","getTime","_applyTimezone","date","timezone","tz","zone","utcOffset","isMoment","DATEONLY","HSTORE","isPlainObject","JSONTYPE","JSON","JSONB","NOW","BLOB","Array","isArray","from","hex","_hexify","RANGE","subtype","_subtype","UUID","isUUID","acceptStrings","UUIDV1","UUIDV4","VIRTUAL","ReturnType","fields","returnType","ENUM","_len","args","_key","values","reduce","element","includes","ARRAY","is","obj","GEOMETRY","srid","Geometry","parseGeoJSON","toWkt","GEOGRAPHY","CIDR","isIPRange","INET","isIP","MACADDR","isMACAddress","TSVECTOR","DataTypes","module","exports","NUMERIC","each","dataType","hasOwnProperty","types","dialectMap","postgres","mysql","mariadb","sqlite","mssql","db2","snowflake","oracle","dialectList","dataTypes","DataType"],"sources":["E:\\Sankey_Project\\node_modules\\sequelize\\src\\data-types.js"],"sourcesContent":["'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst wkx = require('wkx');\nconst sequelizeErrors = require('./errors');\nconst Validator = require('./utils/validator-extras').validator;\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\nconst { logger } = require('./utils/logger');\nconst warnings = {};\nconst { classToInvokable } = require('./utils/class-to-invokable');\nconst { joinSQLFragments } = require('./utils/join-sql-fragments');\n\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \\n>> Check: ${link}`);\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\n\nABSTRACT.prototype.dialectTypes = '';\n\n/**\n * STRING A variable length string\n */\nclass STRING extends ABSTRACT {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super();\n    const options = typeof length === 'object' && length || { length, binary };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return joinSQLFragments([\n      `VARCHAR(${this._length})`,\n      this._binary && 'BINARY'\n    ]);\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== '[object String]') {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\n\n/**\n * CHAR A fixed length string\n */\nclass CHAR extends STRING {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super(typeof length === 'object' && length || { length, binary });\n  }\n  toSql() {\n    return joinSQLFragments([\n      `CHAR(${this._length})`,\n      this._binary && 'BINARY'\n    ]);\n  }\n}\n\n/**\n * Unlimited length TEXT column\n */\nclass TEXT extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYTEXT';\n      case 'medium':\n        return 'MEDIUMTEXT';\n      case 'long':\n        return 'LONGTEXT';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * An unlimited length case-insensitive text column.\n * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).\n * Only available in Postgres and SQLite.\n *\n */\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return 'CITEXT';\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Base number type which is used to build other types\n */\nclass NUMBER extends ABSTRACT {\n  /**\n   * @param {object} options type options\n   * @param {string|number} [options.length] length of type, like `INT(4)`\n   * @param {boolean} [options.zerofill] Is zero filled?\n   * @param {boolean} [options.unsigned] Is unsigned?\n   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   * @param {string|number} [options.precision] defines precision for decimal type\n   * @param {string|number} [options.scale] defines scale for decimal type\n   */\n  constructor(options = {}) {\n    super();\n    if (typeof options === 'number') {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += `(${this._length}`;\n      if (typeof this._decimals === 'number') {\n        result += `,${this._decimals}`;\n      }\n      result += ')';\n    }\n    if (this._unsigned) {\n      result += ' UNSIGNED';\n    }\n    if (this._zerofill) {\n      result += ' ZEROFILL';\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === 'number' || typeof number === 'bigint' || typeof number === 'boolean' || number === null || number === undefined) {\n      return number;\n    }\n    if (typeof number.toString === 'function') {\n      return number.toString();\n    }\n    return number;\n  }\n\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\n\n/**\n * A 32 bit integer\n */\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n}\n\n/**\n * A 8 bit integer\n */\nclass TINYINT extends INTEGER {\n}\n\n/**\n * A 16 bit integer\n */\nclass SMALLINT extends INTEGER {\n}\n\n/**\n * A 24 bit integer\n */\nclass MEDIUMINT extends INTEGER {\n}\n\n/**\n * A 64 bit integer\n */\nclass BIGINT extends INTEGER {\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass FLOAT extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `FLOAT(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass REAL extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `REAL(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Floating point number (8-byte precision).\n */\nclass DOUBLE extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`\n   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Decimal type, variable precision, take length as specified by user\n */\nclass DECIMAL extends NUMBER {\n  /**\n   * @param {string|number} [precision] defines precision\n   * @param {string|number} [scale] defines scale\n   */\n  constructor(precision, scale) {\n    super(typeof precision === 'object' && precision || { precision, scale });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(',')})`;\n    }\n    return 'DECIMAL';\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));\n    }\n    return true;\n  }\n}\n\n// TODO: Create intermediate class\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return 'NaN';\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? '-' : '';\n      return `${sign}Infinity`;\n    }\n\n    return value;\n  },\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\n\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\n\n/**\n * A boolean / tinyint column, depending on dialect\n */\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return 'TINYINT(1)';\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== undefined) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        // Bit fields are returned as buffers\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === 'string') {\n        // Only take action on valid boolean strings.\n        return value === 'true' ? true : value === 'false' ? false : value;\n      }\n      if (type === 'number') {\n        // Only take action on valid boolean integers.\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\n\n\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n/**\n * A time column\n *\n */\nclass TIME extends ABSTRACT {\n  toSql() {\n    return 'TIME';\n  }\n}\n\n/**\n * Date column with timezone, default is UTC\n */\nclass DATE extends ABSTRACT {\n  /**\n   * @param {string|number} [length] precision to allow storing milliseconds\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    return 'DATETIME';\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value &&\n      (value === originalValue ||\n        value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    if (!moment.isMoment(date)) {\n      date = this._applyTimezone(date, options);\n    }\n    // Z here means current timezone, _not_ UTC\n    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n  }\n}\n\n/**\n * A date only column (no timestamp)\n */\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return 'DATE';\n  }\n  _stringify(date) {\n    return moment(date).format('YYYY-MM-DD');\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * A key / value store column. Only available in Postgres.\n */\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A JSON string column. Available in MySQL, Postgres and SQLite\n */\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\n\n/**\n * A binary storage JSON column. Only available in Postgres.\n */\nclass JSONB extends JSONTYPE {\n}\n\n/**\n * A default value of the current timestamp\n */\nclass NOW extends ABSTRACT {\n}\n\n/**\n * Binary storage\n */\nclass BLOB extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYBLOB';\n      case 'medium':\n        return 'MEDIUMBLOB';\n      case 'long':\n        return 'LONGBLOB';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString('hex');\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\n\n\nBLOB.prototype.escape = false;\n\n/**\n * Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details\n */\nclass RANGE extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)\n   */\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : { subtype };\n    if (!options.subtype)\n      options.subtype = new INTEGER();\n    if (typeof options.subtype === 'function') {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError('A range must be an array with two elements');\n    }\n    return true;\n  }\n}\n\n/**\n * A column storing a unique universal identifier.\n * Use with `UUIDV1` or `UUIDV4` for default values.\n */\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v1 standard\n */\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v4 standard\n */\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n *\n * @example <caption>Checking password length before hashing it</caption>\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password', val);\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n *\n * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * @example <caption>Virtual with dependency fields</caption>\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n *\n */\nclass VIRTUAL extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} [ReturnType] return type for virtual type\n   * @param {Array} [fields] array of fields this virtual type is dependent on\n   */\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === 'function')\n      ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\n\n/**\n * An enumeration, Postgres Only\n *\n * @example\n * DataTypes.ENUM('value', 'another value')\n * DataTypes.ENUM(['value', 'another value'])\n * DataTypes.ENUM({\n *   values: ['value', 'another value']\n * })\n */\nclass ENUM extends ABSTRACT {\n  /**\n   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values\n   */\n  constructor(...args) {\n    super();\n    const value = args[0];\n    const options = typeof value === 'object' && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));\n    }\n    return true;\n  }\n}\n\n/**\n * An array of `type`. Only available in Postgres.\n *\n * @example\n * DataTypes.ARRAY(DataTypes.DECIMAL)\n */\nclass ARRAY extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} type type of array values\n   */\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type };\n    this.options = options;\n    this.type = typeof options.type === 'function' ? new options.type() : options.type;\n  }\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\n\n/**\n * A column storing Geometry information.\n * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.\n *\n * GeoJSON is accepted as input and returned as output.\n *\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\n * In MySQL it is parsed using the function `ST_GeomFromText`.\n *\n * Therefore, one can just follow the [GeoJSON spec](https://tools.ietf.org/html/rfc7946) for handling geometry objects.  See the following examples:\n *\n * @example <caption>Defining a Geometry type attribute</caption>\n * DataTypes.GEOMETRY\n * DataTypes.GEOMETRY('POINT')\n * DataTypes.GEOMETRY('POINT', 4326)\n *\n * @example <caption>Create a new point</caption>\n * const point = { type: 'Point', coordinates: [-76.984722, 39.807222]}; // GeoJson format: [lng, lat]\n *\n * User.create({username: 'username', geometry: point });\n *\n * @example <caption>Create a new linestring</caption>\n * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line });\n *\n * @example <caption>Create a new polygon</caption>\n * const polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon });\n *\n * @example <caption>Create a new point with a custom SRID</caption>\n * const point = {\n *   type: 'Point',\n *   coordinates: [-76.984722, 39.807222], // GeoJson format: [lng, lat]\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point })\n *\n *\n * @see {@link DataTypes.GEOGRAPHY}\n */\nclass GEOMETRY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geometry data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\nGEOMETRY.prototype.escape = false;\n\n/**\n * A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n *\n * __The difference from geometry and geography type:__\n *\n * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.\n * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),\n * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.\n *\n * __What is best to use? It depends:__\n *\n * When choosing between the geometry and geography type for data storage, you should consider what you’ll be using it for.\n * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely you’ll be better off storing your data using the new geography type.\n * Although the new geography data type can cover the globe, the geometry type is far from obsolete.\n * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools\n *\n * @example <caption>Defining a Geography type attribute</caption>\n * DataTypes.GEOGRAPHY\n * DataTypes.GEOGRAPHY('POINT')\n * DataTypes.GEOGRAPHY('POINT', 4326)\n */\nclass GEOGRAPHY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geography data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\n\nGEOGRAPHY.prototype.escape = false;\n\n/**\n * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.\n *\n * Only available for Postgres\n */\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes\n *\n * Only available for Postgres\n */\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The MACADDR type stores MAC addresses. Takes 6 bytes\n *\n * Only available for Postgres\n *\n */\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The TSVECTOR type stores text search vectors.\n *\n * Only available for Postgres\n *\n */\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:\n * ```js\n * sequelize.define('model', {\n *   column: DataTypes.INTEGER\n * })\n * ```\n * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\n * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n *\n * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n *\n * Some data types have special properties that can be accessed in order to change the data type.\n * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\n * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.\n *\n * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`\n * * The `CHAR` and `STRING` types expose the `BINARY` property\n *\n * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\n * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *     primaryKey: true\n *   }\n * })\n * ```\n * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished\n * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\n * from a function.\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: function() {\n *       return generateMyId()\n *     },\n *     primaryKey: true\n *   }\n * })\n * ```\n */\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  'DOUBLE PRECISION': DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n\n_.each(DataTypes, (dataType, name) => {\n  // guard for aliases\n  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\n\nconst dialectMap = {};\ndialectMap.postgres = require('./dialects/postgres/data-types')(DataTypes);\ndialectMap.mysql = require('./dialects/mysql/data-types')(DataTypes);\ndialectMap.mariadb = require('./dialects/mariadb/data-types')(DataTypes);\ndialectMap.sqlite = require('./dialects/sqlite/data-types')(DataTypes);\ndialectMap.mssql = require('./dialects/mssql/data-types')(DataTypes);\ndialectMap.db2 = require('./dialects/db2/data-types')(DataTypes);\ndialectMap.snowflake = require('./dialects/snowflake/data-types')(DataTypes);\ndialectMap.oracle = require('./dialects/oracle/data-types')(DataTypes);\n\nconst dialectList = Object.values(dialectMap);\n\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\n\n// Wrap all data types to not require `new`\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\n\nObject.assign(DataTypes, dialectMap);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}