{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = require(\"./../utils\");\nconst Helpers = require(\"./helpers\");\nconst _ = require(\"lodash\");\nconst Association = require(\"./base\");\nconst Op = require(\"../operators\");\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.options.through) {\n      throw new Error(\"N:M associations are not supported with hasMany. Use belongsToMany instead\");\n    }\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([this.source.options.name.singular, this.source.primaryKeyAttribute].join(\"_\"));\n    }\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: \"get\".concat(plural),\n      set: \"set\".concat(plural),\n      addMultiple: \"add\".concat(plural),\n      add: \"add\".concat(singular),\n      create: \"create\".concat(singular),\n      remove: \"remove\".concat(singular),\n      removeMultiple: \"remove\".concat(plural),\n      hasSingle: \"has\".concat(singular),\n      hasAll: \"has\".concat(plural),\n      count: \"count\".concat(plural)\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    const constraintOptions = __spreadValues({}, this.options);\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      constraintOptions.onUpdate = constraintOptions.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instances) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const where = {};\n    let Model = this.target;\n    let instance;\n    let values;\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    options = __spreadValues({}, options);\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n    if (instances) {\n      values = instances.map(_instance => _instance.get(this.sourceKey, {\n        raw: true\n      }));\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this,\n          values\n        };\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, {\n        raw: true\n      });\n    }\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n    const results = await Model.findAll(options);\n    if (instance) return results;\n    const result = {};\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, {\n        raw: true\n      })] = [];\n    }\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, {\n        raw: true\n      })].push(_instance);\n    }\n    return result;\n  }\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n    options.attributes = [[this.sequelize.fn(\"COUNT\", this.sequelize.col(\"\".concat(this.target.name, \".\").concat(this.target.primaryKeyField))), \"count\"]];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    });\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [where, options.where]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return associatedObjects.length === targetInstances.length;\n  }\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n    const oldAssociations = await this.get(sourceInstance, __spreadProps(__spreadValues({}, options), {\n      scope: false,\n      raw: true\n    }));\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter(old => !targetInstances.find(obj => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    const unassociatedObjects = targetInstances.filter(obj => !oldAssociations.find(old => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    let updateWhere;\n    let update;\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject => associatedObject[this.target.primaryKeyAttribute])\n      };\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject => unassociatedObject[this.target.primaryKeyAttribute]);\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    await Promise.all(promises);\n    return sourceInstance;\n  }\n  async add(sourceInstance, targetInstances) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!targetInstances) return Promise.resolve();\n    targetInstances = this.toInstanceArray(targetInstances);\n    const update = __spreadValues({\n      [this.foreignKey]: sourceInstance.get(this.sourceKey)\n    }, this.scope);\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject => unassociatedObject.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n      where\n    }));\n    return sourceInstance;\n  }\n  async remove(sourceInstance, targetInstances) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const update = {\n      [this.foreignKey]: null\n    };\n    targetInstances = this.toInstanceArray(targetInstances);\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance => targetInstance.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n      where\n    }));\n    return this;\n  }\n  async create(sourceInstance, values) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (values === void 0) {\n      values = {};\n    }\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields) options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;","map":{"version":3,"names":["Utils","require","Helpers","_","Association","Op","HasMany","constructor","source","target","options","associationType","targetAssociation","sequelize","isMultiAssociation","foreignKeyAttribute","through","Error","isSelfAssociation","as","isAliased","isPlainObject","name","plural","singular","singularize","isObject","foreignKey","fieldName","camelize","primaryKeyAttribute","join","rawAttributes","identifierField","field","foreignKeyField","sourceKey","sourceKeyAttribute","sourceKeyField","primaryKeyField","upperFirst","associationAccessor","accessors","get","concat","set","addMultiple","add","create","remove","removeMultiple","hasSingle","hasAll","count","_injectAttributes","newAttributes","__spreadValues","type","keyType","allowNull","constraintOptions","constraints","onDelete","onUpdate","addForeignKeyConstraints","mergeDefaults","refreshAttributes","checkNamingCollision","mixin","obj","methods","aliases","mixinMethods","instances","arguments","length","undefined","where","Model","instance","values","Array","isArray","scope","Object","assign","map","_instance","raw","limit","groupedLimit","on","in","and","prototype","hasOwnProperty","call","unscoped","schema","schemaDelimiter","results","findAll","result","push","cloneDeep","attributes","fn","col","plain","parseInt","has","sourceInstance","targetInstances","__spreadProps","or","associatedObjects","toInstanceArray","oldAssociations","promises","obsoleteAssociations","filter","old","find","unassociatedObjects","updateWhere","update","associatedObject","unassociatedObject","Promise","all","resolve","targetInstance","fields","attribute","keys","verifyAssociationAlias","alias","module","exports","default"],"sources":["E:\\Sankey_Project\\node_modules\\sequelize\\src\\associations\\has-many.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n\n    /*\n    * If self association, this is the target association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    /*\n     * Foreign key setup\n     */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.source.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    /*\n     * Source key setup\n     */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n\n    // Get singular and plural names\n    // try to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: {\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true,\n        ...this.foreignKeyAttribute\n      }\n    };\n\n    // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n    const constraintOptions = { ...this.options };\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findAll}  for a full explanation of options\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  async get(instances, options = {}) {\n    const where = {};\n\n    let Model = this.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    options = { ...options };\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    if (instances) {\n      values = instances.map(_instance => _instance.get(this.sourceKey, { raw: true }));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this, // association\n          values\n        };\n\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    const results = await Model.findAll(options);\n    if (instance) return results;\n\n    const result = {};\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, { raw: true })] = [];\n    }\n\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);\n    }\n\n    return result;\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model}        instance the source instance\n   * @param {object}         [options] find & count options\n   * @param {object}         [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n\n    options.attributes = [\n      [\n        this.sequelize.fn(\n          'COUNT',\n          this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)\n        ),\n        'count'\n      ]\n    ];\n    options.raw = true;\n    options.plain = true;\n\n    const result = await this.get(instance, options);\n\n    return parseInt(result.count, 10);\n  }\n\n  /**\n   * Check if one or more rows are associated with `this`.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys\n   * @param {object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise}\n   */\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = {\n      ...options,\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    };\n\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n\n    const associatedObjects = await this.get(sourceInstance, options);\n\n    return associatedObjects.length === targetInstances.length;\n  }\n\n  /**\n   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {object} [options] Options passed to `target.findAll` and `update`.\n   * @param {object} [options.validate] Run validation for the join model\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n\n    const oldAssociations = await this.get(sourceInstance, { ...options, scope: false, raw: true });\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter(old =>\n      !targetInstances.find(obj =>\n        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n      )\n    );\n    const unassociatedObjects = targetInstances.filter(obj =>\n      !oldAssociations.find(old =>\n        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n      )\n    );\n    let updateWhere;\n    let update;\n\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject =>\n          associatedObject[this.target.primaryKeyAttribute]\n        )\n      };\n\n\n      promises.push(this.target.unscoped().update(\n        update,\n        {\n          ...options,\n          where: updateWhere\n        }\n      ));\n    }\n\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>\n        unassociatedObject[this.target.primaryKeyAttribute]\n      );\n\n      promises.push(this.target.unscoped().update(\n        update,\n        {\n          ...options,\n          where: updateWhere\n        }\n      ));\n    }\n\n    await Promise.all(promises);\n\n    return sourceInstance;\n  }\n\n  /**\n   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n   * or a mixed array of Model / string / numbers to associate multiple rows.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `target.update`.\n   *\n   * @returns {Promise}\n   */\n  async add(sourceInstance, targetInstances, options = {}) {\n    if (!targetInstances) return Promise.resolve();\n\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const update = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      ...this.scope\n    };\n\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject =>\n        unassociatedObject.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    await this.target.unscoped().update(update, { ...options, where });\n\n    return sourceInstance;\n  }\n\n  /**\n   * Un-associate one or several target rows.\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {object} [options] Options passed to `target.update`\n   *\n   * @returns {Promise}\n   */\n  async remove(sourceInstance, targetInstances, options = {}) {\n    const update = {\n      [this.foreignKey]: null\n    };\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance =>\n        targetInstance.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    await this.target.unscoped().update(update, { ...options, where });\n\n    return this;\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {object} [values] values for target model instance\n   * @param {object} [options] Options passed to `target.create`\n   *\n   * @returns {Promise}\n   */\n  async create(sourceInstance, values, options = {}) {\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === undefined) {\n      values = {};\n    }\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields) options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}